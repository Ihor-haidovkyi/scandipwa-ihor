{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _toConsumableArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{cacheNames}from'workbox-core/_private/cacheNames.js';import{cacheWrapper}from'workbox-core/_private/cacheWrapper.js';import{fetchWrapper}from'workbox-core/_private/fetchWrapper.js';import{getFriendlyURL}from'workbox-core/_private/getFriendlyURL.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{messages}from\"./utils/messages.js\";import{cacheOkAndOpaquePlugin}from\"./plugins/cacheOkAndOpaquePlugin.js\";import\"./_version.js\";/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */var NetworkFirst=/*#__PURE__*/function(){/**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */function NetworkFirst(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,NetworkFirst);this._cacheName=cacheNames.getRuntimeName(options.cacheName);if(options.plugins){var isUsingCacheWillUpdate=options.plugins.some(function(plugin){return!!plugin.cacheWillUpdate;});this._plugins=isUsingCacheWillUpdate?options.plugins:[cacheOkAndOpaquePlugin].concat(_toConsumableArray(options.plugins));}else{// No plugins passed in, use the default plugin.\nthis._plugins=[cacheOkAndOpaquePlugin];}this._networkTimeoutSeconds=options.networkTimeoutSeconds||0;if(process.env.NODE_ENV!=='production'){if(this._networkTimeoutSeconds){assert.isType(this._networkTimeoutSeconds,'number',{moduleName:'workbox-strategies',className:'NetworkFirst',funcName:'constructor',paramName:'networkTimeoutSeconds'});}}this._fetchOptions=options.fetchOptions;this._matchOptions=options.matchOptions;}/**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */_createClass(NetworkFirst,[{key:\"handle\",value:function(){var _handle=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var event,request,logs,promises,timeoutId,_this$_getTimeoutProm,id,promise,networkPromise,response,_iterator,_step,log;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:event=_ref.event,request=_ref.request;logs=[];if(typeof request==='string'){request=new Request(request);}if(process.env.NODE_ENV!=='production'){assert.isInstance(request,Request,{moduleName:'workbox-strategies',className:'NetworkFirst',funcName:'handle',paramName:'makeRequest'});}promises=[];if(this._networkTimeoutSeconds){_this$_getTimeoutProm=this._getTimeoutPromise({request:request,event:event,logs:logs}),id=_this$_getTimeoutProm.id,promise=_this$_getTimeoutProm.promise;timeoutId=id;promises.push(promise);}networkPromise=this._getNetworkPromise({timeoutId:timeoutId,request:request,event:event,logs:logs});promises.push(networkPromise);// Promise.race() will resolve as soon as the first promise resolves.\n_context.next=10;return Promise.race(promises);case 10:response=_context.sent;if(response){_context.next=15;break;}_context.next=14;return networkPromise;case 14:response=_context.sent;case 15:if(process.env.NODE_ENV!=='production'){logger.groupCollapsed(messages.strategyStart('NetworkFirst',request));_iterator=_createForOfIteratorHelper(logs);try{for(_iterator.s();!(_step=_iterator.n()).done;){log=_step.value;logger.log(log);}}catch(err){_iterator.e(err);}finally{_iterator.f();}messages.printFinalResponse(response);logger.groupEnd();}if(response){_context.next=18;break;}throw new WorkboxError('no-response',{url:request.url});case 18:return _context.abrupt(\"return\",response);case 19:case\"end\":return _context.stop();}}},_callee,this);}));function handle(_x){return _handle.apply(this,arguments);}return handle;}()/**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */},{key:\"_getTimeoutPromise\",value:function _getTimeoutPromise(_ref2){var _this=this;var request=_ref2.request,logs=_ref2.logs,event=_ref2.event;var timeoutId;var timeoutPromise=new Promise(function(resolve){var onNetworkTimeout=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(process.env.NODE_ENV!=='production'){logs.push(\"Timing out the network response at \"+\"\".concat(_this._networkTimeoutSeconds,\" seconds.\"));}_context2.t0=resolve;_context2.next=4;return _this._respondFromCache({request:request,event:event});case 4:_context2.t1=_context2.sent;(0,_context2.t0)(_context2.t1);case 6:case\"end\":return _context2.stop();}}},_callee2);}));return function onNetworkTimeout(){return _ref3.apply(this,arguments);};}();timeoutId=setTimeout(onNetworkTimeout,_this._networkTimeoutSeconds*1000);});return{promise:timeoutPromise,id:timeoutId};}/**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */},{key:\"_getNetworkPromise\",value:function(){var _getNetworkPromise2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4){var timeoutId,request,logs,event,error,response,responseClone,cachePut;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:timeoutId=_ref4.timeoutId,request=_ref4.request,logs=_ref4.logs,event=_ref4.event;_context3.prev=1;_context3.next=4;return fetchWrapper.fetch({request:request,event:event,fetchOptions:this._fetchOptions,plugins:this._plugins});case 4:response=_context3.sent;_context3.next=10;break;case 7:_context3.prev=7;_context3.t0=_context3[\"catch\"](1);error=_context3.t0;case 10:if(timeoutId){clearTimeout(timeoutId);}if(process.env.NODE_ENV!=='production'){if(response){logs.push(\"Got response from network.\");}else{logs.push(\"Unable to get a response from the network. Will respond \"+\"with a cached response.\");}}if(!(error||!response)){_context3.next=19;break;}_context3.next=15;return this._respondFromCache({request:request,event:event});case 15:response=_context3.sent;if(process.env.NODE_ENV!=='production'){if(response){logs.push(\"Found a cached response in the '\".concat(this._cacheName,\"'\")+\" cache.\");}else{logs.push(\"No response found in the '\".concat(this._cacheName,\"' cache.\"));}}_context3.next=22;break;case 19:// Keep the service worker alive while we put the request in the cache\nresponseClone=response.clone();cachePut=cacheWrapper.put({cacheName:this._cacheName,request:request,response:responseClone,event:event,plugins:this._plugins});if(event){try{// The event has been responded to so we can keep the SW alive to\n// respond to the request\nevent.waitUntil(cachePut);}catch(err){if(process.env.NODE_ENV!=='production'){logger.warn(\"Unable to ensure service worker stays alive when \"+\"updating cache for '\".concat(getFriendlyURL(request.url),\"'.\"));}}}case 22:return _context3.abrupt(\"return\",response);case 23:case\"end\":return _context3.stop();}}},_callee3,this,[[1,7]]);}));function _getNetworkPromise(_x2){return _getNetworkPromise2.apply(this,arguments);}return _getNetworkPromise;}()/**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */},{key:\"_respondFromCache\",value:function _respondFromCache(_ref5){var event=_ref5.event,request=_ref5.request;return cacheWrapper.match({cacheName:this._cacheName,request:request,event:event,matchOptions:this._matchOptions,plugins:this._plugins});}}]);return NetworkFirst;}();export{NetworkFirst};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-strategies/NetworkFirst.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","getFriendlyURL","logger","WorkboxError","messages","cacheOkAndOpaquePlugin","NetworkFirst","options","_cacheName","getRuntimeName","cacheName","plugins","isUsingCacheWillUpdate","some","plugin","cacheWillUpdate","_plugins","_networkTimeoutSeconds","networkTimeoutSeconds","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","logs","Request","isInstance","promises","_getTimeoutPromise","id","promise","timeoutId","push","networkPromise","_getNetworkPromise","Promise","race","response","groupCollapsed","strategyStart","log","printFinalResponse","groupEnd","url","timeoutPromise","resolve","onNetworkTimeout","_respondFromCache","setTimeout","fetch","error","clearTimeout","responseClone","clone","cachePut","put","waitUntil","err","warn","match"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkFirst',\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, event, logs });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, event, logs });\n        promises.push(networkPromise);\n        // Promise.race() will resolve as soon as the first promise resolves.\n        let response = await Promise.race(promises);\n        // If Promise.race() resolved with null, it might be due to a network\n        // timeout + a cache miss. If that were to happen, we'd rather wait until\n        // the networkPromise resolves instead of returning null.\n        // Note that it's fine to await an already-resolved promise, so we don't\n        // have to check to see if it's still \"in flight\".\n        if (!response) {\n            response = await networkPromise;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, event }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await this._respondFromCache({ request, event }));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, event }) {\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await this._respondFromCache({ request, event });\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this._cacheName}'` +\n                        ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this._cacheName}' cache.`);\n                }\n            }\n        }\n        else {\n            // Keep the service worker alive while we put the request in the cache\n            const responseClone = response.clone();\n            const cachePut = cacheWrapper.put({\n                cacheName: this._cacheName,\n                request,\n                response: responseClone,\n                event,\n                plugins: this._plugins,\n            });\n            if (event) {\n                try {\n                    // The event has been responded to so we can keep the SW alive to\n                    // respond to the request\n                    event.waitUntil(cachePut);\n                }\n                catch (err) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n    _respondFromCache({ event, request }) {\n        return cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n    }\n}\nexport { NetworkFirst };\n"]},"metadata":{},"sourceType":"module"}