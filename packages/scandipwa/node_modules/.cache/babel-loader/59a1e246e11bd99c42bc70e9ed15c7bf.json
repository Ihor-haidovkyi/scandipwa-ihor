{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from\"./assert.js\";import{executeQuotaErrorCallbacks}from\"./executeQuotaErrorCallbacks.js\";import{getFriendlyURL}from\"./getFriendlyURL.js\";import{logger}from\"./logger.js\";import{pluginUtils}from\"../utils/pluginUtils.js\";import{WorkboxError}from\"./WorkboxError.js\";import\"../_version.js\";/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */var _getEffectiveRequest=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var request,mode,_ref$plugins,plugins,cacheKeyWillBeUsedPlugins,effectiveRequest,_iterator,_step,plugin;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:request=_ref.request,mode=_ref.mode,_ref$plugins=_ref.plugins,plugins=_ref$plugins===void 0?[]:_ref$plugins;cacheKeyWillBeUsedPlugins=pluginUtils.filter(plugins,\"cacheKeyWillBeUsed\"/* CACHE_KEY_WILL_BE_USED */);effectiveRequest=request;_iterator=_createForOfIteratorHelper(cacheKeyWillBeUsedPlugins);_context.prev=4;_iterator.s();case 6:if((_step=_iterator.n()).done){_context.next=15;break;}plugin=_step.value;_context.next=10;return plugin[\"cacheKeyWillBeUsed\"/* CACHE_KEY_WILL_BE_USED */].call(plugin,{mode:mode,request:effectiveRequest});case 10:effectiveRequest=_context.sent;if(typeof effectiveRequest==='string'){effectiveRequest=new Request(effectiveRequest);}if(process.env.NODE_ENV!=='production'){assert.isInstance(effectiveRequest,Request,{moduleName:'Plugin',funcName:\"cacheKeyWillBeUsed\"/* CACHE_KEY_WILL_BE_USED */,isReturnValueProblem:true});}case 13:_context.next=6;break;case 15:_context.next=20;break;case 17:_context.prev=17;_context.t0=_context[\"catch\"](4);_iterator.e(_context.t0);case 20:_context.prev=20;_iterator.f();return _context.finish(20);case 23:return _context.abrupt(\"return\",effectiveRequest);case 24:case\"end\":return _context.stop();}}},_callee,null,[[4,17,20,23]]);}));return function _getEffectiveRequest(_x){return _ref2.apply(this,arguments);};}();/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */var _isResponseSafeToCache=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3){var request,response,event,_ref3$plugins,plugins,responseToCache,pluginsUsed,_iterator2,_step2,plugin,pluginMethod;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:request=_ref3.request,response=_ref3.response,event=_ref3.event,_ref3$plugins=_ref3.plugins,plugins=_ref3$plugins===void 0?[]:_ref3$plugins;responseToCache=response;pluginsUsed=false;_iterator2=_createForOfIteratorHelper(plugins);_context2.prev=4;_iterator2.s();case 6:if((_step2=_iterator2.n()).done){_context2.next=19;break;}plugin=_step2.value;if(!(\"cacheWillUpdate\"/* CACHE_WILL_UPDATE */in plugin)){_context2.next=17;break;}pluginsUsed=true;pluginMethod=plugin[\"cacheWillUpdate\"/* CACHE_WILL_UPDATE */];_context2.next=13;return pluginMethod.call(plugin,{request:request,response:responseToCache,event:event});case 13:responseToCache=_context2.sent;if(process.env.NODE_ENV!=='production'){if(responseToCache){assert.isInstance(responseToCache,Response,{moduleName:'Plugin',funcName:\"cacheWillUpdate\"/* CACHE_WILL_UPDATE */,isReturnValueProblem:true});}}if(responseToCache){_context2.next=17;break;}return _context2.abrupt(\"break\",19);case 17:_context2.next=6;break;case 19:_context2.next=24;break;case 21:_context2.prev=21;_context2.t0=_context2[\"catch\"](4);_iterator2.e(_context2.t0);case 24:_context2.prev=24;_iterator2.f();return _context2.finish(24);case 27:if(!pluginsUsed){if(process.env.NODE_ENV!=='production'){if(responseToCache){if(responseToCache.status!==200){if(responseToCache.status===0){logger.warn(\"The response for '\".concat(request.url,\"' is an opaque \")+\"response. The caching strategy that you're using will not \"+\"cache opaque responses by default.\");}else{logger.debug(\"The response for '\".concat(request.url,\"' returned \")+\"a status code of '\".concat(response.status,\"' and won't be cached as a \")+\"result.\");}}}}responseToCache=responseToCache&&responseToCache.status===200?responseToCache:undefined;}return _context2.abrupt(\"return\",responseToCache?responseToCache:null);case 29:case\"end\":return _context2.stop();}}},_callee2,null,[[4,21,24,27]]);}));return function _isResponseSafeToCache(_x2){return _ref4.apply(this,arguments);};}();/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */var matchWrapper=/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5){var cacheName,request,event,matchOptions,_ref5$plugins,plugins,cache,effectiveRequest,cachedResponse,_iterator3,_step3,plugin,pluginMethod;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:cacheName=_ref5.cacheName,request=_ref5.request,event=_ref5.event,matchOptions=_ref5.matchOptions,_ref5$plugins=_ref5.plugins,plugins=_ref5$plugins===void 0?[]:_ref5$plugins;_context3.next=3;return self.caches.open(cacheName);case 3:cache=_context3.sent;_context3.next=6;return _getEffectiveRequest({plugins:plugins,request:request,mode:'read'});case 6:effectiveRequest=_context3.sent;_context3.next=9;return cache.match(effectiveRequest,matchOptions);case 9:cachedResponse=_context3.sent;if(process.env.NODE_ENV!=='production'){if(cachedResponse){logger.debug(\"Found a cached response in '\".concat(cacheName,\"'.\"));}else{logger.debug(\"No cached response found in '\".concat(cacheName,\"'.\"));}}_iterator3=_createForOfIteratorHelper(plugins);_context3.prev=12;_iterator3.s();case 14:if((_step3=_iterator3.n()).done){_context3.next=24;break;}plugin=_step3.value;if(!(\"cachedResponseWillBeUsed\"/* CACHED_RESPONSE_WILL_BE_USED */in plugin)){_context3.next=22;break;}pluginMethod=plugin[\"cachedResponseWillBeUsed\"/* CACHED_RESPONSE_WILL_BE_USED */];_context3.next=20;return pluginMethod.call(plugin,{cacheName:cacheName,event:event,matchOptions:matchOptions,cachedResponse:cachedResponse,request:effectiveRequest});case 20:cachedResponse=_context3.sent;if(process.env.NODE_ENV!=='production'){if(cachedResponse){assert.isInstance(cachedResponse,Response,{moduleName:'Plugin',funcName:\"cachedResponseWillBeUsed\"/* CACHED_RESPONSE_WILL_BE_USED */,isReturnValueProblem:true});}}case 22:_context3.next=14;break;case 24:_context3.next=29;break;case 26:_context3.prev=26;_context3.t0=_context3[\"catch\"](12);_iterator3.e(_context3.t0);case 29:_context3.prev=29;_iterator3.f();return _context3.finish(29);case 32:return _context3.abrupt(\"return\",cachedResponse);case 33:case\"end\":return _context3.stop();}}},_callee3,null,[[12,26,29,32]]);}));return function matchWrapper(_x3){return _ref6.apply(this,arguments);};}();/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */var putWrapper=/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref7){var cacheName,request,response,event,_ref7$plugins,plugins,matchOptions,effectiveRequest,responseToCache,cache,updatePlugins,oldResponse,_iterator4,_step4,plugin;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:cacheName=_ref7.cacheName,request=_ref7.request,response=_ref7.response,event=_ref7.event,_ref7$plugins=_ref7.plugins,plugins=_ref7$plugins===void 0?[]:_ref7$plugins,matchOptions=_ref7.matchOptions;if(!(process.env.NODE_ENV!=='production')){_context4.next=4;break;}if(!(request.method&&request.method!=='GET')){_context4.next=4;break;}throw new WorkboxError('attempt-to-cache-non-get-request',{url:getFriendlyURL(request.url),method:request.method});case 4:_context4.next=6;return _getEffectiveRequest({plugins:plugins,request:request,mode:'write'});case 6:effectiveRequest=_context4.sent;if(response){_context4.next=10;break;}if(process.env.NODE_ENV!=='production'){logger.error(\"Cannot cache non-existent response for \"+\"'\".concat(getFriendlyURL(effectiveRequest.url),\"'.\"));}throw new WorkboxError('cache-put-with-no-response',{url:getFriendlyURL(effectiveRequest.url)});case 10:_context4.next=12;return _isResponseSafeToCache({event:event,plugins:plugins,response:response,request:effectiveRequest});case 12:responseToCache=_context4.sent;if(responseToCache){_context4.next=16;break;}if(process.env.NODE_ENV!=='production'){logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url),\"' will \")+\"not be cached.\",responseToCache);}return _context4.abrupt(\"return\");case 16:_context4.next=18;return self.caches.open(cacheName);case 18:cache=_context4.sent;updatePlugins=pluginUtils.filter(plugins,\"cacheDidUpdate\"/* CACHE_DID_UPDATE */);if(!(updatePlugins.length>0)){_context4.next=26;break;}_context4.next=23;return matchWrapper({cacheName:cacheName,matchOptions:matchOptions,request:effectiveRequest});case 23:_context4.t0=_context4.sent;_context4.next=27;break;case 26:_context4.t0=null;case 27:oldResponse=_context4.t0;if(process.env.NODE_ENV!=='production'){logger.debug(\"Updating the '\".concat(cacheName,\"' cache with a new Response for \")+\"\".concat(getFriendlyURL(effectiveRequest.url),\".\"));}_context4.prev=29;_context4.next=32;return cache.put(effectiveRequest,responseToCache);case 32:_context4.next=40;break;case 34:_context4.prev=34;_context4.t1=_context4[\"catch\"](29);if(!(_context4.t1.name==='QuotaExceededError')){_context4.next=39;break;}_context4.next=39;return executeQuotaErrorCallbacks();case 39:throw _context4.t1;case 40:_iterator4=_createForOfIteratorHelper(updatePlugins);_context4.prev=41;_iterator4.s();case 43:if((_step4=_iterator4.n()).done){_context4.next=49;break;}plugin=_step4.value;_context4.next=47;return plugin[\"cacheDidUpdate\"/* CACHE_DID_UPDATE */].call(plugin,{cacheName:cacheName,event:event,oldResponse:oldResponse,newResponse:responseToCache,request:effectiveRequest});case 47:_context4.next=43;break;case 49:_context4.next=54;break;case 51:_context4.prev=51;_context4.t2=_context4[\"catch\"](41);_iterator4.e(_context4.t2);case 54:_context4.prev=54;_iterator4.f();return _context4.finish(54);case 57:case\"end\":return _context4.stop();}}},_callee4,null,[[29,34],[41,51,54,57]]);}));return function putWrapper(_x4){return _ref8.apply(this,arguments);};}();export var cacheWrapper={put:putWrapper,match:matchWrapper};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-core/_private/cacheWrapper.js"],"names":["assert","executeQuotaErrorCallbacks","getFriendlyURL","logger","pluginUtils","WorkboxError","_getEffectiveRequest","request","mode","plugins","cacheKeyWillBeUsedPlugins","filter","effectiveRequest","plugin","call","Request","process","env","NODE_ENV","isInstance","moduleName","funcName","isReturnValueProblem","_isResponseSafeToCache","response","event","responseToCache","pluginsUsed","pluginMethod","Response","status","warn","url","debug","undefined","matchWrapper","cacheName","matchOptions","self","caches","open","cache","match","cachedResponse","putWrapper","method","error","updatePlugins","length","oldResponse","put","name","newResponse","cacheWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from './assert.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport { WorkboxError } from './WorkboxError.js';\nimport '../_version.js';\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that prompted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await self.caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    const responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await self.caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    const oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (const plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n"]},"metadata":{},"sourceType":"module"}