{"ast":null,"code":"import{createElement,Component,useRef,useState,useCallback,useEffect}from'react';function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}var ObserverMap=new Map();var RootIds=new Map();var rootId=0;/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */function getRootId(root){if(!root)return'0';if(RootIds.has(root))return RootIds.get(root);rootId+=1;RootIds.set(root,rootId.toString());return RootIds.get(root);}/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */function optionsToId(options){return Object.keys(options).sort().filter(function(key){return options[key]!==undefined;}).map(function(key){return key+\"_\"+(key==='root'?getRootId(options.root):options[key]);}).toString();}function createObserver(options){// Create a unique ID for this observer instance, based on the root, root margin and threshold.\nvar id=optionsToId(options);var instance=ObserverMap.get(id);if(!instance){// Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\nvar elements=new Map();var thresholds;var observer=new IntersectionObserver(function(entries){entries.forEach(function(entry){var _elements$get;// While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n// -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\nvar inView=entry.isIntersecting&&thresholds.some(function(threshold){return entry.intersectionRatio>=threshold;});// @ts-ignore support IntersectionObserver v2\nif(options.trackVisibility&&typeof entry.isVisible==='undefined'){// The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n// @ts-ignore\nentry.isVisible=inView;}(_elements$get=elements.get(entry.target))==null?void 0:_elements$get.forEach(function(callback){callback(inView,entry);});});},options);// Ensure we have a valid thresholds array. If not, use the threshold from the options\nthresholds=observer.thresholds||(Array.isArray(options.threshold)?options.threshold:[options.threshold||0]);instance={id:id,observer:observer,elements:elements};ObserverMap.set(id,instance);}return instance;}function observe(element,callback,options){if(options===void 0){options={};}if(!element)return function(){};// An observer with the same options can be reused, so lets use this fact\nvar _createObserver=createObserver(options),id=_createObserver.id,observer=_createObserver.observer,elements=_createObserver.elements;// Register the callback listener for this element\nvar callbacks=elements.get(element)||[];if(!elements.has(element)){elements.set(element,callbacks);}callbacks.push(callback);observer.observe(element);return function unobserve(){// Remove the callback from the callback list\ncallbacks.splice(callbacks.indexOf(callback),1);if(callbacks.length===0){// No more callback exists for element, so destroy it\nelements[\"delete\"](element);observer.unobserve(element);}if(elements.size===0){// No more elements are being observer by this instance, so destroy it\nobserver.disconnect();ObserverMap[\"delete\"](id);}};}function isPlainChildren(props){return typeof props.children!=='function';}/**\r\n * Monitors scroll, and triggers the children function with updated props\r\n */var InView=/*#__PURE__*/function(_React$Component){_inheritsLoose(InView,_React$Component);function InView(props){var _this;_this=_React$Component.call(this,props)||this;_this.node=null;_this._unobserveCb=null;_this.handleNode=function(node){if(_this.node){// Clear the old observer, before we start observing a new element\n_this.unobserve();if(!node&&!_this.props.triggerOnce&&!_this.props.skip){// Reset the state if we get a new node, and we aren't ignoring updates\n_this.setState({inView:!!_this.props.initialInView,entry:undefined});}}_this.node=node?node:null;_this.observeNode();};_this.handleChange=function(inView,entry){if(inView&&_this.props.triggerOnce){// If `triggerOnce` is true, we should stop observing the element.\n_this.unobserve();}if(!isPlainChildren(_this.props)){// Store the current State, so we can pass it to the children in the next render update\n// There's no reason to update the state for plain children, since it's not used in the rendering.\n_this.setState({inView:inView,entry:entry});}if(_this.props.onChange){// If the user is actively listening for onChange, always trigger it\n_this.props.onChange(inView,entry);}};_this.state={inView:!!props.initialInView,entry:undefined};return _this;}var _proto=InView.prototype;_proto.componentDidUpdate=function componentDidUpdate(prevProps){// If a IntersectionObserver option changed, reinit the observer\nif(prevProps.rootMargin!==this.props.rootMargin||prevProps.root!==this.props.root||prevProps.threshold!==this.props.threshold||prevProps.skip!==this.props.skip||prevProps.trackVisibility!==this.props.trackVisibility||prevProps.delay!==this.props.delay){this.unobserve();this.observeNode();}};_proto.componentWillUnmount=function componentWillUnmount(){this.unobserve();this.node=null;};_proto.observeNode=function observeNode(){if(!this.node||this.props.skip)return;var _this$props=this.props,threshold=_this$props.threshold,root=_this$props.root,rootMargin=_this$props.rootMargin,trackVisibility=_this$props.trackVisibility,delay=_this$props.delay;this._unobserveCb=observe(this.node,this.handleChange,{threshold:threshold,root:root,rootMargin:rootMargin,// @ts-ignore\ntrackVisibility:trackVisibility,// @ts-ignore\ndelay:delay});};_proto.unobserve=function unobserve(){if(this._unobserveCb){this._unobserveCb();this._unobserveCb=null;}};_proto.render=function render(){if(!isPlainChildren(this.props)){var _this$state=this.state,inView=_this$state.inView,entry=_this$state.entry;return this.props.children({inView:inView,entry:entry,ref:this.handleNode});}var _this$props2=this.props,children=_this$props2.children,as=_this$props2.as,tag=_this$props2.tag,props=_objectWithoutPropertiesLoose(_this$props2,[\"children\",\"as\",\"tag\",\"triggerOnce\",\"threshold\",\"root\",\"rootMargin\",\"onChange\",\"skip\",\"trackVisibility\",\"delay\",\"initialInView\"]);return/*#__PURE__*/createElement(as||tag||'div',_extends({ref:this.handleNode},props),children);};return InView;}(Component);InView.displayName='InView';InView.defaultProps={threshold:0,triggerOnce:false,initialInView:false};function useInView(_temp){var _ref=_temp===void 0?{}:_temp,threshold=_ref.threshold,delay=_ref.delay,trackVisibility=_ref.trackVisibility,rootMargin=_ref.rootMargin,root=_ref.root,triggerOnce=_ref.triggerOnce,skip=_ref.skip,initialInView=_ref.initialInView;var unobserve=useRef();var _React$useState=useState({inView:!!initialInView}),state=_React$useState[0],setState=_React$useState[1];var setRef=useCallback(function(node){if(unobserve.current!==undefined){unobserve.current();unobserve.current=undefined;}// Skip creating the observer\nif(skip)return;if(node){unobserve.current=observe(node,function(inView,entry){setState({inView:inView,entry:entry});if(entry.isIntersecting&&triggerOnce&&unobserve.current){// If it should only trigger once, unobserve the element after it's inView\nunobserve.current();unobserve.current=undefined;}},{root:root,rootMargin:rootMargin,threshold:threshold,// @ts-ignore\ntrackVisibility:trackVisibility,// @ts-ignore\ndelay:delay});}},// We break the rule here, because we aren't including the actual `threshold` variable\n// eslint-disable-next-line react-hooks/exhaustive-deps\n[// If the threshold is an array, convert it to a string so it won't change between renders.\n// eslint-disable-next-line react-hooks/exhaustive-deps\nArray.isArray(threshold)?threshold.toString():threshold,root,rootMargin,triggerOnce,skip,trackVisibility,delay]);/* eslint-disable-next-line */useEffect(function(){if(!unobserve.current&&state.entry&&!triggerOnce&&!skip){// If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n// This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\nsetState({inView:!!initialInView});}});var result=[setRef,state.inView,state.entry];// Support object destructuring, by adding the specific values.\nresult.ref=result[0];result.inView=result[1];result.entry=result[2];return result;}export default InView;export{InView,useInView};","map":{"version":3,"sources":["../src/observers.ts","../src/InView.tsx","../src/useInView.tsx"],"names":["ObserverMap","RootIds","rootId","optionsToId","options","key","getRootId","id","instance","elements","observer","entries","inView","entry","callback","thresholds","Array","observe","element","createObserver","callbacks","props","InView","threshold","triggerOnce","initialInView","undefined","componentDidUpdate","prevProps","componentWillUnmount","observeNode","root","rootMargin","trackVisibility","delay","unobserve","node","isPlainChildren","render","ref","handleNode","children","as","tag","useInView","skip","React","state","setState","setRef","useEffect","result"],"mappings":"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","sourcesContent":["import { ObserverInstanceCallback } from './index';\n\nconst ObserverMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: Map<Element, string> = new Map();\n\nlet rootId = 0;\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter((key) => options[key] !== undefined)\n    .map((key) => {\n      return `${key}_${\n        key === 'root' ? getRootId(options.root) : options[key]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = ObserverMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-ignore support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    ObserverMap.set(id, instance);\n  }\n\n  return instance;\n}\n\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  if (!element) return () => {};\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  let callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      ObserverMap.delete(id);\n    }\n  };\n}\n","import * as React from 'react';\nimport { IntersectionObserverProps, PlainChildrenProps } from './index';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function';\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  static displayName = 'InView';\n  static defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n    initialInView: false,\n  };\n\n  constructor(props: IntersectionObserverProps | PlainChildrenProps) {\n    super(props);\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined,\n    };\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip ||\n      prevProps.trackVisibility !== this.props.trackVisibility ||\n      prevProps.delay !== this.props.delay\n    ) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  node: Element | null = null;\n  _unobserveCb: (() => void) | null = null;\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const { threshold, root, rootMargin, trackVisibility, delay } = this.props;\n\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay,\n    });\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      // Clear the old observer, before we start observing a new element\n      this.unobserve();\n\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        // Reset the state if we get a new node, and we aren't ignoring updates\n        this.setState({ inView: !!this.props.initialInView, entry: undefined });\n      }\n    }\n    this.node = node ? node : null;\n    this.observeNode();\n  };\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    if (inView && this.props.triggerOnce) {\n      // If `triggerOnce` is true, we should stop observing the element.\n      this.unobserve();\n    }\n    if (!isPlainChildren(this.props)) {\n      // Store the current State, so we can pass it to the children in the next render update\n      // There's no reason to update the state for plain children, since it's not used in the rendering.\n      this.setState({ inView, entry });\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry);\n    }\n  };\n\n  render() {\n    if (!isPlainChildren(this.props)) {\n      const { inView, entry } = this.state;\n      return this.props.children({ inView, entry, ref: this.handleNode });\n    }\n\n    const {\n      children,\n      as,\n      tag,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      skip,\n      trackVisibility,\n      delay,\n      initialInView,\n      ...props\n    } = this.props;\n\n    return React.createElement(\n      as || tag || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    );\n  }\n}\n","import * as React from 'react';\nimport { InViewHookResponse, IntersectionOptions } from './index';\nimport { useEffect } from 'react';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nexport function useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n}: IntersectionOptions = {}): InViewHookResponse {\n  const unobserve = React.useRef<Function>();\n  const [state, setState] = React.useState<State>({\n    inView: !!initialInView,\n  });\n\n  const setRef = React.useCallback(\n    (node) => {\n      if (unobserve.current !== undefined) {\n        unobserve.current();\n        unobserve.current = undefined;\n      }\n\n      // Skip creating the observer\n      if (skip) return;\n\n      if (node) {\n        unobserve.current = observe(\n          node,\n          (inView, entry) => {\n            setState({ inView, entry });\n\n            if (entry.isIntersecting && triggerOnce && unobserve.current) {\n              // If it should only trigger once, unobserve the element after it's inView\n              unobserve.current();\n              unobserve.current = undefined;\n            }\n          },\n          {\n            root,\n            rootMargin,\n            threshold,\n            // @ts-ignore\n            trackVisibility,\n            // @ts-ignore\n            delay,\n          },\n        );\n      }\n    },\n    // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // If the threshold is an array, convert it to a string so it won't change between renders.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      trackVisibility,\n      delay,\n    ],\n  );\n\n  /* eslint-disable-next-line */\n  useEffect(() => {\n    if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView,\n      });\n    }\n  });\n\n  const result = [setRef, state.inView, state.entry] as InViewHookResponse;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}