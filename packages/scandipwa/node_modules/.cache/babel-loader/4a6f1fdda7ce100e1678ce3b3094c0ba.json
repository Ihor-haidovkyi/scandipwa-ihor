{"ast":null,"code":"import _slicedToArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{cacheNames}from'workbox-core/_private/cacheNames.js';import{dontWaitFor}from'workbox-core/_private/dontWaitFor.js';import{getFriendlyURL}from'workbox-core/_private/getFriendlyURL.js';import{logger}from'workbox-core/_private/logger.js';import{registerQuotaErrorCallback}from'workbox-core/registerQuotaErrorCallback.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{CacheExpiration}from\"./CacheExpiration.js\";import\"./_version.js\";/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */var ExpirationPlugin=/*#__PURE__*/function(){/**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */function ExpirationPlugin(){var _this=this;var config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,ExpirationPlugin);/**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */this.cachedResponseWillBeUsed=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var event,request,cacheName,cachedResponse,isFresh,cacheExpiration,updateTimestampDone;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:event=_ref.event,request=_ref.request,cacheName=_ref.cacheName,cachedResponse=_ref.cachedResponse;if(cachedResponse){_context.next=3;break;}return _context.abrupt(\"return\",null);case 3:isFresh=_this._isResponseDateFresh(cachedResponse);// Expire entries to ensure that even if the expiration date has\n// expired, it'll only be used once.\ncacheExpiration=_this._getCacheExpiration(cacheName);dontWaitFor(cacheExpiration.expireEntries());// Update the metadata for the request URL to the current timestamp,\n// but don't `await` it as we don't want to block the response.\nupdateTimestampDone=cacheExpiration.updateTimestamp(request.url);if(event){try{event.waitUntil(updateTimestampDone);}catch(error){if(process.env.NODE_ENV!=='production'){// The event may not be a fetch event; only log the URL if it is.\nif('request'in event){logger.warn(\"Unable to ensure service worker stays alive when \"+\"updating cache entry for \"+\"'\".concat(getFriendlyURL(event.request.url),\"'.\"));}}}}return _context.abrupt(\"return\",isFresh?cachedResponse:null);case 9:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref2.apply(this,arguments);};}();/**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */this.cacheDidUpdate=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3){var cacheName,request,cacheExpiration;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:cacheName=_ref3.cacheName,request=_ref3.request;if(process.env.NODE_ENV!=='production'){assert.isType(cacheName,'string',{moduleName:'workbox-expiration',className:'Plugin',funcName:'cacheDidUpdate',paramName:'cacheName'});assert.isInstance(request,Request,{moduleName:'workbox-expiration',className:'Plugin',funcName:'cacheDidUpdate',paramName:'request'});}cacheExpiration=_this._getCacheExpiration(cacheName);_context2.next=5;return cacheExpiration.updateTimestamp(request.url);case 5:_context2.next=7;return cacheExpiration.expireEntries();case 7:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref4.apply(this,arguments);};}();if(process.env.NODE_ENV!=='production'){if(!(config.maxEntries||config.maxAgeSeconds)){throw new WorkboxError('max-entries-or-age-required',{moduleName:'workbox-expiration',className:'Plugin',funcName:'constructor'});}if(config.maxEntries){assert.isType(config.maxEntries,'number',{moduleName:'workbox-expiration',className:'Plugin',funcName:'constructor',paramName:'config.maxEntries'});}if(config.maxAgeSeconds){assert.isType(config.maxAgeSeconds,'number',{moduleName:'workbox-expiration',className:'Plugin',funcName:'constructor',paramName:'config.maxAgeSeconds'});}}this._config=config;this._maxAgeSeconds=config.maxAgeSeconds;this._cacheExpirations=new Map();if(config.purgeOnQuotaError){registerQuotaErrorCallback(function(){return _this.deleteCacheAndMetadata();});}}/**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */_createClass(ExpirationPlugin,[{key:\"_getCacheExpiration\",value:function _getCacheExpiration(cacheName){if(cacheName===cacheNames.getRuntimeName()){throw new WorkboxError('expire-custom-caches-only');}var cacheExpiration=this._cacheExpirations.get(cacheName);if(!cacheExpiration){cacheExpiration=new CacheExpiration(cacheName,this._config);this._cacheExpirations.set(cacheName,cacheExpiration);}return cacheExpiration;}/**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */},{key:\"_isResponseDateFresh\",value:function _isResponseDateFresh(cachedResponse){if(!this._maxAgeSeconds){// We aren't expiring by age, so return true, it's fresh\nreturn true;}// Check if the 'date' header will suffice a quick expiration check.\n// See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n// discussion.\nvar dateHeaderTimestamp=this._getDateHeaderTimestamp(cachedResponse);if(dateHeaderTimestamp===null){// Unable to parse date, so assume it's fresh.\nreturn true;}// If we have a valid headerTime, then our response is fresh iff the\n// headerTime plus maxAgeSeconds is greater than the current time.\nvar now=Date.now();return dateHeaderTimestamp>=now-this._maxAgeSeconds*1000;}/**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */},{key:\"_getDateHeaderTimestamp\",value:function _getDateHeaderTimestamp(cachedResponse){if(!cachedResponse.headers.has('date')){return null;}var dateHeader=cachedResponse.headers.get('date');var parsedDate=new Date(dateHeader);var headerTime=parsedDate.getTime();// If the Date header was invalid for some reason, parsedDate.getTime()\n// will return NaN.\nif(isNaN(headerTime)){return null;}return headerTime;}/**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */},{key:\"deleteCacheAndMetadata\",value:function(){var _deleteCacheAndMetadata=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){var _iterator,_step,_step$value,cacheName,cacheExpiration;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:// Do this one at a time instead of all at once via `Promise.all()` to\n// reduce the chance of inconsistency if a promise rejects.\n_iterator=_createForOfIteratorHelper(this._cacheExpirations);_context3.prev=1;_iterator.s();case 3:if((_step=_iterator.n()).done){_context3.next=11;break;}_step$value=_slicedToArray(_step.value,2),cacheName=_step$value[0],cacheExpiration=_step$value[1];_context3.next=7;return self.caches.delete(cacheName);case 7:_context3.next=9;return cacheExpiration.delete();case 9:_context3.next=3;break;case 11:_context3.next=16;break;case 13:_context3.prev=13;_context3.t0=_context3[\"catch\"](1);_iterator.e(_context3.t0);case 16:_context3.prev=16;_iterator.f();return _context3.finish(16);case 19:// Reset this._cacheExpirations to its initial state.\nthis._cacheExpirations=new Map();case 20:case\"end\":return _context3.stop();}}},_callee3,this,[[1,13,16,19]]);}));function deleteCacheAndMetadata(){return _deleteCacheAndMetadata.apply(this,arguments);}return deleteCacheAndMetadata;}()}]);return ExpirationPlugin;}();export{ExpirationPlugin};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-expiration/ExpirationPlugin.js"],"names":["assert","cacheNames","dontWaitFor","getFriendlyURL","logger","registerQuotaErrorCallback","WorkboxError","CacheExpiration","ExpirationPlugin","config","cachedResponseWillBeUsed","event","request","cacheName","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","expireEntries","updateTimestampDone","updateTimestamp","url","waitUntil","error","process","env","NODE_ENV","warn","cacheDidUpdate","isType","moduleName","className","funcName","paramName","isInstance","Request","maxEntries","maxAgeSeconds","_config","_maxAgeSeconds","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","getRuntimeName","get","set","dateHeaderTimestamp","_getDateHeaderTimestamp","now","Date","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","self","caches","delete"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n"]},"metadata":{},"sourceType":"module"}