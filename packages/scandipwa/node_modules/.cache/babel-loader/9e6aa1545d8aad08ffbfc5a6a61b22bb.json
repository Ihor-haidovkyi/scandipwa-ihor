{"ast":null,"code":"import _toConsumableArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _slicedToArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{cacheNames}from'workbox-core/_private/cacheNames.js';import{cacheWrapper}from'workbox-core/_private/cacheWrapper.js';import{fetchWrapper}from'workbox-core/_private/fetchWrapper.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{copyResponse}from'workbox-core/copyResponse.js';import{createCacheKey}from\"./utils/createCacheKey.js\";import{printCleanupDetails}from\"./utils/printCleanupDetails.js\";import{printInstallDetails}from\"./utils/printInstallDetails.js\";import\"./_version.js\";/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */var PrecacheController=/*#__PURE__*/function(){/**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */function PrecacheController(cacheName){_classCallCheck(this,PrecacheController);this._cacheName=cacheNames.getPrecacheName(cacheName);this._urlsToCacheKeys=new Map();this._urlsToCacheModes=new Map();this._cacheKeysToIntegrities=new Map();}/**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */_createClass(PrecacheController,[{key:\"addToCacheList\",value:function addToCacheList(entries){if(process.env.NODE_ENV!=='production'){assert.isArray(entries,{moduleName:'workbox-precaching',className:'PrecacheController',funcName:'addToCacheList',paramName:'entries'});}var urlsToWarnAbout=[];var _iterator=_createForOfIteratorHelper(entries),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var entry=_step.value;// See https://github.com/GoogleChrome/workbox/issues/2259\nif(typeof entry==='string'){urlsToWarnAbout.push(entry);}else if(entry&&entry.revision===undefined){urlsToWarnAbout.push(entry.url);}var _createCacheKey=createCacheKey(entry),cacheKey=_createCacheKey.cacheKey,url=_createCacheKey.url;var cacheMode=typeof entry!=='string'&&entry.revision?'reload':'default';if(this._urlsToCacheKeys.has(url)&&this._urlsToCacheKeys.get(url)!==cacheKey){throw new WorkboxError('add-to-cache-list-conflicting-entries',{firstEntry:this._urlsToCacheKeys.get(url),secondEntry:cacheKey});}if(typeof entry!=='string'&&entry.integrity){if(this._cacheKeysToIntegrities.has(cacheKey)&&this._cacheKeysToIntegrities.get(cacheKey)!==entry.integrity){throw new WorkboxError('add-to-cache-list-conflicting-integrities',{url:url});}this._cacheKeysToIntegrities.set(cacheKey,entry.integrity);}this._urlsToCacheKeys.set(url,cacheKey);this._urlsToCacheModes.set(url,cacheMode);if(urlsToWarnAbout.length>0){var warningMessage=\"Workbox is precaching URLs without revision \"+\"info: \".concat(urlsToWarnAbout.join(', '),\"\\nThis is generally NOT safe. \")+\"Learn more at https://bit.ly/wb-precache\";if(process.env.NODE_ENV==='production'){// Use console directly to display this warning without bloating\n// bundle sizes by pulling in all of the logger codebase in prod.\nconsole.warn(warningMessage);}else{logger.warn(warningMessage);}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}/**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */},{key:\"install\",value:function(){var _install=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var _this=this;var _ref,event,plugins,toBePrecached,alreadyPrecached,cache,alreadyCachedRequests,existingCacheKeys,_iterator2,_step2,_step2$value,url,cacheKey,precacheRequests,updatedURLs,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_ref=_args.length>0&&_args[0]!==undefined?_args[0]:{},event=_ref.event,plugins=_ref.plugins;if(process.env.NODE_ENV!=='production'){if(plugins){assert.isArray(plugins,{moduleName:'workbox-precaching',className:'PrecacheController',funcName:'install',paramName:'plugins'});}}toBePrecached=[];alreadyPrecached=[];_context.next=6;return self.caches.open(this._cacheName);case 6:cache=_context.sent;_context.next=9;return cache.keys();case 9:alreadyCachedRequests=_context.sent;existingCacheKeys=new Set(alreadyCachedRequests.map(function(request){return request.url;}));_iterator2=_createForOfIteratorHelper(this._urlsToCacheKeys);try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){_step2$value=_slicedToArray(_step2.value,2),url=_step2$value[0],cacheKey=_step2$value[1];if(existingCacheKeys.has(cacheKey)){alreadyPrecached.push(url);}else{toBePrecached.push({cacheKey:cacheKey,url:url});}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}precacheRequests=toBePrecached.map(function(_ref2){var cacheKey=_ref2.cacheKey,url=_ref2.url;var integrity=_this._cacheKeysToIntegrities.get(cacheKey);var cacheMode=_this._urlsToCacheModes.get(url);return _this._addURLToCache({cacheKey:cacheKey,cacheMode:cacheMode,event:event,integrity:integrity,plugins:plugins,url:url});});_context.next=16;return Promise.all(precacheRequests);case 16:updatedURLs=toBePrecached.map(function(item){return item.url;});if(process.env.NODE_ENV!=='production'){printInstallDetails(updatedURLs,alreadyPrecached);}return _context.abrupt(\"return\",{updatedURLs:updatedURLs,notUpdatedURLs:alreadyPrecached});case 19:case\"end\":return _context.stop();}}},_callee,this);}));function install(){return _install.apply(this,arguments);}return install;}()/**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */},{key:\"activate\",value:function(){var _activate=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var cache,currentlyCachedRequests,expectedCacheKeys,deletedURLs,_iterator3,_step3,request;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return self.caches.open(this._cacheName);case 2:cache=_context2.sent;_context2.next=5;return cache.keys();case 5:currentlyCachedRequests=_context2.sent;expectedCacheKeys=new Set(this._urlsToCacheKeys.values());deletedURLs=[];_iterator3=_createForOfIteratorHelper(currentlyCachedRequests);_context2.prev=9;_iterator3.s();case 11:if((_step3=_iterator3.n()).done){_context2.next=19;break;}request=_step3.value;if(expectedCacheKeys.has(request.url)){_context2.next=17;break;}_context2.next=16;return cache.delete(request);case 16:deletedURLs.push(request.url);case 17:_context2.next=11;break;case 19:_context2.next=24;break;case 21:_context2.prev=21;_context2.t0=_context2[\"catch\"](9);_iterator3.e(_context2.t0);case 24:_context2.prev=24;_iterator3.f();return _context2.finish(24);case 27:if(process.env.NODE_ENV!=='production'){printCleanupDetails(deletedURLs);}return _context2.abrupt(\"return\",{deletedURLs:deletedURLs});case 29:case\"end\":return _context2.stop();}}},_callee2,this,[[9,21,24,27]]);}));function activate(){return _activate.apply(this,arguments);}return activate;}()/**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */},{key:\"_addURLToCache\",value:function(){var _addURLToCache2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3){var cacheKey,url,cacheMode,event,plugins,integrity,request,response,cacheWillUpdatePlugin,_iterator4,_step4,plugin,isValidResponse;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:cacheKey=_ref3.cacheKey,url=_ref3.url,cacheMode=_ref3.cacheMode,event=_ref3.event,plugins=_ref3.plugins,integrity=_ref3.integrity;request=new Request(url,{integrity:integrity,cache:cacheMode,credentials:'same-origin'});_context3.next=4;return fetchWrapper.fetch({event:event,plugins:plugins,request:request});case 4:response=_context3.sent;_iterator4=_createForOfIteratorHelper(plugins||[]);try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){plugin=_step4.value;if('cacheWillUpdate'in plugin){cacheWillUpdatePlugin=plugin;}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}if(!cacheWillUpdatePlugin){_context3.next=13;break;}_context3.next=10;return cacheWillUpdatePlugin.cacheWillUpdate({event:event,request:request,response:response});case 10:_context3.t0=_context3.sent;_context3.next=14;break;case 13:_context3.t0=// Otherwise, default to considering any response status under 400 valid.\n// This includes, by default, considering opaque responses valid.\nresponse.status<400;case 14:isValidResponse=_context3.t0;if(isValidResponse){_context3.next=17;break;}throw new WorkboxError('bad-precaching-response',{url:url,status:response.status});case 17:if(!response.redirected){_context3.next=21;break;}_context3.next=20;return copyResponse(response);case 20:response=_context3.sent;case 21:_context3.next=23;return cacheWrapper.put({event:event,plugins:plugins,response:response,// `request` already uses `url`. We may be able to reuse it.\nrequest:cacheKey===url?request:new Request(cacheKey),cacheName:this._cacheName,matchOptions:{ignoreSearch:true}});case 23:case\"end\":return _context3.stop();}}},_callee3,this);}));function _addURLToCache(_x){return _addURLToCache2.apply(this,arguments);}return _addURLToCache;}()/**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */},{key:\"getURLsToCacheKeys\",value:function getURLsToCacheKeys(){return this._urlsToCacheKeys;}/**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */},{key:\"getCachedURLs\",value:function getCachedURLs(){return _toConsumableArray(this._urlsToCacheKeys.keys());}/**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */},{key:\"getCacheKeyForURL\",value:function getCacheKeyForURL(url){var urlObject=new URL(url,location.href);return this._urlsToCacheKeys.get(urlObject.href);}/**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */},{key:\"matchPrecache\",value:function(){var _matchPrecache=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(request){var url,cacheKey,cache;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:url=request instanceof Request?request.url:request;cacheKey=this.getCacheKeyForURL(url);if(!cacheKey){_context4.next=7;break;}_context4.next=5;return self.caches.open(this._cacheName);case 5:cache=_context4.sent;return _context4.abrupt(\"return\",cache.match(cacheKey));case 7:return _context4.abrupt(\"return\",undefined);case 8:case\"end\":return _context4.stop();}}},_callee4,this);}));function matchPrecache(_x2){return _matchPrecache.apply(this,arguments);}return matchPrecache;}()/**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */},{key:\"createHandler\",value:function createHandler(){var _this2=this;var fallbackToNetwork=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;return/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref4){var request,response;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:request=_ref4.request;_context5.prev=1;_context5.next=4;return _this2.matchPrecache(request);case 4:response=_context5.sent;if(!response){_context5.next=7;break;}return _context5.abrupt(\"return\",response);case 7:throw new WorkboxError('missing-precache-entry',{cacheName:_this2._cacheName,url:request instanceof Request?request.url:request});case 10:_context5.prev=10;_context5.t0=_context5[\"catch\"](1);if(!fallbackToNetwork){_context5.next=15;break;}if(process.env.NODE_ENV!=='production'){logger.debug(\"Unable to respond with precached response. \"+\"Falling back to network.\",_context5.t0);}return _context5.abrupt(\"return\",fetch(request));case 15:throw _context5.t0;case 16:case\"end\":return _context5.stop();}}},_callee5,null,[[1,10]]);}));return function(_x3){return _ref5.apply(this,arguments);};}();}/**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */},{key:\"createHandlerBoundToURL\",value:function createHandlerBoundToURL(url){var fallbackToNetwork=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var cacheKey=this.getCacheKeyForURL(url);if(!cacheKey){throw new WorkboxError('non-precached-url',{url:url});}var handler=this.createHandler(fallbackToNetwork);var request=new Request(url);return function(){return handler({request:request});};}}]);return PrecacheController;}();export{PrecacheController};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-precaching/PrecacheController.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","logger","WorkboxError","copyResponse","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","event","plugins","toBePrecached","alreadyPrecached","self","caches","open","cache","keys","alreadyCachedRequests","existingCacheKeys","Set","map","request","precacheRequests","_addURLToCache","Promise","all","updatedURLs","item","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","Request","credentials","fetch","response","plugin","cacheWillUpdatePlugin","cacheWillUpdate","status","isValidResponse","redirected","put","matchOptions","ignoreSearch","urlObject","URL","location","href","getCacheKeyForURL","match","fallbackToNetwork","matchPrecache","debug","handler","createHandler"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = (typeof entry !== 'string' && entry.revision) ?\n                'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            return this._addURLToCache({\n                cacheKey,\n                cacheMode,\n                event,\n                integrity,\n                plugins,\n                url,\n            });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, cacheMode, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: cacheMode,\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            await cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this._cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandler(fallbackToNetwork = true) {\n        return async ({ request }) => {\n            try {\n                const response = await this.matchPrecache(request);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new WorkboxError('missing-precache-entry', {\n                    cacheName: this._cacheName,\n                    url: request instanceof Request ? request.url : request,\n                });\n            }\n            catch (error) {\n                if (fallbackToNetwork) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.debug(`Unable to respond with precached response. ` +\n                            `Falling back to network.`, error);\n                    }\n                    return fetch(request);\n                }\n                throw error;\n            }\n        };\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({ request });\n    }\n}\nexport { PrecacheController };\n"]},"metadata":{},"sourceType":"module"}