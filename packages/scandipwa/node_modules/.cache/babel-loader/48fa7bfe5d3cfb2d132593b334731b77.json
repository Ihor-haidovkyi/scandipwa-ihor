{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{cacheNames}from'workbox-core/_private/cacheNames.js';import{cacheWrapper}from'workbox-core/_private/cacheWrapper.js';import{fetchWrapper}from'workbox-core/_private/fetchWrapper.js';import{getFriendlyURL}from'workbox-core/_private/getFriendlyURL.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{messages}from\"./utils/messages.js\";import\"./_version.js\";/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */var CacheFirst=/*#__PURE__*/function(){/**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */function CacheFirst(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,CacheFirst);this._cacheName=cacheNames.getRuntimeName(options.cacheName);this._plugins=options.plugins||[];this._fetchOptions=options.fetchOptions;this._matchOptions=options.matchOptions;}/**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */_createClass(CacheFirst,[{key:\"handle\",value:function(){var _handle=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var event,request,logs,response,error,_iterator,_step,log;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:event=_ref.event,request=_ref.request;logs=[];if(typeof request==='string'){request=new Request(request);}if(process.env.NODE_ENV!=='production'){assert.isInstance(request,Request,{moduleName:'workbox-strategies',className:'CacheFirst',funcName:'makeRequest',paramName:'request'});}_context.next=6;return cacheWrapper.match({cacheName:this._cacheName,request:request,event:event,matchOptions:this._matchOptions,plugins:this._plugins});case 6:response=_context.sent;if(response){_context.next=21;break;}if(process.env.NODE_ENV!=='production'){logs.push(\"No response found in the '\".concat(this._cacheName,\"' cache. \")+\"Will respond with a network request.\");}_context.prev=9;_context.next=12;return this._getFromNetwork(request,event);case 12:response=_context.sent;_context.next=18;break;case 15:_context.prev=15;_context.t0=_context[\"catch\"](9);error=_context.t0;case 18:if(process.env.NODE_ENV!=='production'){if(response){logs.push(\"Got response from network.\");}else{logs.push(\"Unable to get a response from the network.\");}}_context.next=22;break;case 21:if(process.env.NODE_ENV!=='production'){logs.push(\"Found a cached response in the '\".concat(this._cacheName,\"' cache.\"));}case 22:if(process.env.NODE_ENV!=='production'){logger.groupCollapsed(messages.strategyStart('CacheFirst',request));_iterator=_createForOfIteratorHelper(logs);try{for(_iterator.s();!(_step=_iterator.n()).done;){log=_step.value;logger.log(log);}}catch(err){_iterator.e(err);}finally{_iterator.f();}messages.printFinalResponse(response);logger.groupEnd();}if(response){_context.next=25;break;}throw new WorkboxError('no-response',{url:request.url,error:error});case 25:return _context.abrupt(\"return\",response);case 26:case\"end\":return _context.stop();}}},_callee,this,[[9,15]]);}));function handle(_x){return _handle.apply(this,arguments);}return handle;}()/**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */},{key:\"_getFromNetwork\",value:function(){var _getFromNetwork2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request,event){var response,responseClone,cachePutPromise;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return fetchWrapper.fetch({request:request,event:event,fetchOptions:this._fetchOptions,plugins:this._plugins});case 2:response=_context2.sent;// Keep the service worker while we put the request to the cache\nresponseClone=response.clone();cachePutPromise=cacheWrapper.put({cacheName:this._cacheName,request:request,response:responseClone,event:event,plugins:this._plugins});if(event){try{event.waitUntil(cachePutPromise);}catch(error){if(process.env.NODE_ENV!=='production'){logger.warn(\"Unable to ensure service worker stays alive when \"+\"updating cache for '\".concat(getFriendlyURL(request.url),\"'.\"));}}}return _context2.abrupt(\"return\",response);case 7:case\"end\":return _context2.stop();}}},_callee2,this);}));function _getFromNetwork(_x2,_x3){return _getFromNetwork2.apply(this,arguments);}return _getFromNetwork;}()}]);return CacheFirst;}();export{CacheFirst};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-strategies/CacheFirst.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","getFriendlyURL","logger","WorkboxError","messages","CacheFirst","options","_cacheName","getRuntimeName","cacheName","_plugins","plugins","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","logs","Request","process","env","NODE_ENV","isInstance","moduleName","className","funcName","paramName","match","response","push","_getFromNetwork","error","groupCollapsed","strategyStart","log","printFinalResponse","groupEnd","url","fetch","responseClone","clone","cachePutPromise","put","waitUntil","warn"],"mappings":"wuBAAA;AACA;AACA;AACA;AACA;AACA;AACA,EACA,OAASA,MAAT,KAAuB,iCAAvB,CACA,OAASC,UAAT,KAA2B,qCAA3B,CACA,OAASC,YAAT,KAA6B,uCAA7B,CACA,OAASC,YAAT,KAA6B,uCAA7B,CACA,OAASC,cAAT,KAA+B,yCAA/B,CACA,OAASC,MAAT,KAAuB,iCAAvB,CACA,OAASC,YAAT,KAA6B,uCAA7B,CACA,OAASC,QAAT,2BACA,sBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,GACMC,CAAAA,U,yBACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,qBAA0B,IAAdC,CAAAA,OAAc,2DAAJ,EAAI,kCACtB,KAAKC,UAAL,CAAkBT,UAAU,CAACU,cAAX,CAA0BF,OAAO,CAACG,SAAlC,CAAlB,CACA,KAAKC,QAAL,CAAgBJ,OAAO,CAACK,OAAR,EAAmB,EAAnC,CACA,KAAKC,aAAL,CAAqBN,OAAO,CAACO,YAA7B,CACA,KAAKC,aAAL,CAAqBR,OAAO,CAACS,YAA7B,CACH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,4HACI,iMAAeC,KAAf,MAAeA,KAAf,CAAsBC,OAAtB,MAAsBA,OAAtB,CACUC,IADV,CACiB,EADjB,CAEI,GAAI,MAAOD,CAAAA,OAAP,GAAmB,QAAvB,CAAiC,CAC7BA,OAAO,CAAG,GAAIE,CAAAA,OAAJ,CAAYF,OAAZ,CAAV,CACH,CACD,GAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCzB,MAAM,CAAC0B,UAAP,CAAkBN,OAAlB,CAA2BE,OAA3B,CAAoC,CAChCK,UAAU,CAAE,oBADoB,CAEhCC,SAAS,CAAE,YAFqB,CAGhCC,QAAQ,CAAE,aAHsB,CAIhCC,SAAS,CAAE,SAJqB,CAApC,EAMH,CAZL,sBAayB5B,CAAAA,YAAY,CAAC6B,KAAb,CAAmB,CACpCnB,SAAS,CAAE,KAAKF,UADoB,CAEpCU,OAAO,CAAPA,OAFoC,CAGpCD,KAAK,CAALA,KAHoC,CAIpCD,YAAY,CAAE,KAAKD,aAJiB,CAKpCH,OAAO,CAAE,KAAKD,QALsB,CAAnB,CAbzB,QAaQmB,QAbR,kBAqBSA,QArBT,0BAsBQ,GAAIT,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCJ,IAAI,CAACY,IAAL,CAAU,oCAA6B,KAAKvB,UAAlC,oDAAV,EAEH,CAzBT,uCA2B6B,MAAKwB,eAAL,CAAqBd,OAArB,CAA8BD,KAA9B,CA3B7B,SA2BYa,QA3BZ,gGA8BYG,KAAK,YAAL,CA9BZ,QAgCQ,GAAIZ,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC,GAAIO,QAAJ,CAAc,CACVX,IAAI,CAACY,IAAL,+BACH,CAFD,IAGK,CACDZ,IAAI,CAACY,IAAL,+CACH,CACJ,CAvCT,+BA0CQ,GAAIV,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCJ,IAAI,CAACY,IAAL,2CAA6C,KAAKvB,UAAlD,cACH,CA5CT,QA8CI,GAAIa,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCpB,MAAM,CAAC+B,cAAP,CAAsB7B,QAAQ,CAAC8B,aAAT,CAAuB,YAAvB,CAAqCjB,OAArC,CAAtB,EADuC,qCAErBC,IAFqB,MAEvC,+CAAwB,CAAbiB,GAAa,aACpBjC,MAAM,CAACiC,GAAP,CAAWA,GAAX,EACH,CAJsC,qDAKvC/B,QAAQ,CAACgC,kBAAT,CAA4BP,QAA5B,EACA3B,MAAM,CAACmC,QAAP,GACH,CArDL,GAsDSR,QAtDT,+BAuDc,IAAI1B,CAAAA,YAAJ,CAAiB,aAAjB,CAAgC,CAAEmC,GAAG,CAAErB,OAAO,CAACqB,GAAf,CAAoBN,KAAK,CAALA,KAApB,CAAhC,CAvDd,yCAyDWH,QAzDX,uE,8EA2DA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,uHACI,kBAAsBZ,OAAtB,CAA+BD,KAA/B,wLAC2BhB,CAAAA,YAAY,CAACuC,KAAb,CAAmB,CACtCtB,OAAO,CAAPA,OADsC,CAEtCD,KAAK,CAALA,KAFsC,CAGtCH,YAAY,CAAE,KAAKD,aAHmB,CAItCD,OAAO,CAAE,KAAKD,QAJwB,CAAnB,CAD3B,QACUmB,QADV,gBAOI;AACMW,aARV,CAQ0BX,QAAQ,CAACY,KAAT,EAR1B,CASUC,eATV,CAS4B3C,YAAY,CAAC4C,GAAb,CAAiB,CACrClC,SAAS,CAAE,KAAKF,UADqB,CAErCU,OAAO,CAAPA,OAFqC,CAGrCY,QAAQ,CAAEW,aAH2B,CAIrCxB,KAAK,CAALA,KAJqC,CAKrCL,OAAO,CAAE,KAAKD,QALuB,CAAjB,CAT5B,CAgBI,GAAIM,KAAJ,CAAW,CACP,GAAI,CACAA,KAAK,CAAC4B,SAAN,CAAgBF,eAAhB,EACH,CACD,MAAOV,KAAP,CAAc,CACV,GAAIZ,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCpB,MAAM,CAAC2C,IAAP,CAAY,kFACe5C,cAAc,CAACgB,OAAO,CAACqB,GAAT,CAD7B,MAAZ,EAEH,CACJ,CACJ,CA1BL,iCA2BWT,QA3BX,+D,wIA8BJ,OAASxB,UAAT","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheFirst',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await this._getFromNetwork(request, event);\n            }\n            catch (err) {\n                error = err;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork(request, event) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        // Keep the service worker while we put the request to the cache\n        const responseClone = response.clone();\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: responseClone,\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n"]},"metadata":{},"sourceType":"module"}