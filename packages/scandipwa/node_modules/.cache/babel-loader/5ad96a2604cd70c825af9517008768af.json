{"ast":null,"code":"/* eslint-disable max-classes-per-file */\nimport generateGetHandler from \"./lib/handlers/generateGetHandler\"; // Key for processable classes to determine whether they are already extensible\n\nconst extensible = Symbol('Extensible');\nconst cacheIdentityKey = Symbol('CacheIdentityKey'); // Cache to optimise class generation\n\nconst generated = []; // eslint-disable-next-line @scandipwa/scandipwa-guidelines/derived-class-names\n\nclass EmptyBase {}\n\nexport default (function (BaseClass = EmptyBase) {\n  // NOTE! Base class is original class which class extends\n  // Handle already extensible classes\n  if (BaseClass[extensible]) {\n    return BaseClass;\n  }\n\n  const {\n    name\n  } = BaseClass; // Get the cache identity for the base class, omit inherited prop\n\n  const {\n    // Generate unique cache identities as default value\n    value: cacheIdentity = Symbol(`Cache Identity ${name}`)\n  } = Object.getOwnPropertyDescriptor(BaseClass, cacheIdentityKey) || {}; // If such class is not yet generated => generate the class\n\n  if (!generated[cacheIdentity]) {\n    /**\n     * What this class does, is:\n     * - extends what original class did extend\n     * - defines a constructor which calls original parent\n     */\n    const GeneratedClass = class Extensible extends BaseClass {\n      constructor(...args) {\n        super(...args);\n        const {\n          __namespaces__\n        } = Object.getPrototypeOf(this);\n        return new Proxy(this, {\n          get: generateGetHandler('instance', __namespaces__)\n        });\n      }\n\n      __construct() {}\n\n    };\n    GeneratedClass[extensible] = true;\n    generated[cacheIdentity] = GeneratedClass;\n    Object.defineProperty(BaseClass, cacheIdentityKey, {\n      value: cacheIdentity,\n      writable: false\n    });\n  }\n\n  return generated[cacheIdentity];\n});","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/@scandipwa/scandipwa-extensibility/Extensible.js"],"names":["generateGetHandler","extensible","Symbol","cacheIdentityKey","generated","EmptyBase","BaseClass","name","value","cacheIdentity","Object","getOwnPropertyDescriptor","GeneratedClass","Extensible","constructor","args","__namespaces__","getPrototypeOf","Proxy","get","__construct","defineProperty","writable"],"mappings":"AAAA;AACA,OAAOA,kBAAP,0C,CAEA;;AACA,MAAMC,UAAU,GAAGC,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMC,gBAAgB,GAAGD,MAAM,CAAC,kBAAD,CAA/B,C,CAEA;;AACA,MAAME,SAAS,GAAG,EAAlB,C,CAEA;;AACA,MAAMC,SAAN,CAAgB;;AAEhB,gBAAe,UAACC,SAAS,GAAGD,SAAb,EAA2B;AACtC;AAEA;AACA,MAAIC,SAAS,CAACL,UAAD,CAAb,EAA2B;AACvB,WAAOK,SAAP;AACH;;AAED,QAAM;AAAEC,IAAAA;AAAF,MAAWD,SAAjB,CARsC,CAStC;;AACA,QAAM;AACF;AACAE,IAAAA,KAAK,EAAEC,aAAa,GAAGP,MAAM,CAAE,kBAAiBK,IAAK,EAAxB;AAF3B,MAGFG,MAAM,CAACC,wBAAP,CAAgCL,SAAhC,EAA2CH,gBAA3C,KAAgE,EAHpE,CAVsC,CAetC;;AACA,MAAI,CAACC,SAAS,CAACK,aAAD,CAAd,EAA+B;AAC3B;AACR;AACA;AACA;AACA;AAEQ,UAAMG,cAAc,GAAG,MAAMC,UAAN,SAAyBP,SAAzB,CAAmC;AACtDQ,MAAAA,WAAW,CAAC,GAAGC,IAAJ,EAAU;AACjB,cAAM,GAAGA,IAAT;AACA,cAAM;AAAEC,UAAAA;AAAF,YAAqBN,MAAM,CAACO,cAAP,CAAsB,IAAtB,CAA3B;AAEA,eAAO,IAAIC,KAAJ,CAAU,IAAV,EAAgB;AACnBC,UAAAA,GAAG,EAAEnB,kBAAkB,CAAC,UAAD,EAAagB,cAAb;AADJ,SAAhB,CAAP;AAGH;;AAEDI,MAAAA,WAAW,GAAG,CAAE;;AAVsC,KAA1D;AAaAR,IAAAA,cAAc,CAACX,UAAD,CAAd,GAA6B,IAA7B;AACAG,IAAAA,SAAS,CAACK,aAAD,CAAT,GAA2BG,cAA3B;AACAF,IAAAA,MAAM,CAACW,cAAP,CACIf,SADJ,EAEIH,gBAFJ,EAGI;AAAEK,MAAAA,KAAK,EAAEC,aAAT;AAAwBa,MAAAA,QAAQ,EAAE;AAAlC,KAHJ;AAKH;;AAED,SAAOlB,SAAS,CAACK,aAAD,CAAhB;AACH,CA9CD","sourcesContent":["/* eslint-disable max-classes-per-file */\nimport generateGetHandler from './lib/handlers/generateGetHandler';\n\n// Key for processable classes to determine whether they are already extensible\nconst extensible = Symbol('Extensible');\nconst cacheIdentityKey = Symbol('CacheIdentityKey');\n\n// Cache to optimise class generation\nconst generated = [];\n\n// eslint-disable-next-line @scandipwa/scandipwa-guidelines/derived-class-names\nclass EmptyBase {}\n\nexport default (BaseClass = EmptyBase) => {\n    // NOTE! Base class is original class which class extends\n\n    // Handle already extensible classes\n    if (BaseClass[extensible]) {\n        return BaseClass;\n    }\n\n    const { name } = BaseClass;\n    // Get the cache identity for the base class, omit inherited prop\n    const {\n        // Generate unique cache identities as default value\n        value: cacheIdentity = Symbol(`Cache Identity ${name}`)\n    } = Object.getOwnPropertyDescriptor(BaseClass, cacheIdentityKey) || {};\n\n    // If such class is not yet generated => generate the class\n    if (!generated[cacheIdentity]) {\n        /**\n         * What this class does, is:\n         * - extends what original class did extend\n         * - defines a constructor which calls original parent\n         */\n\n        const GeneratedClass = class Extensible extends BaseClass {\n            constructor(...args) {\n                super(...args);\n                const { __namespaces__ } = Object.getPrototypeOf(this);\n\n                return new Proxy(this, {\n                    get: generateGetHandler('instance', __namespaces__)\n                });\n            }\n\n            __construct() {}\n        };\n\n        GeneratedClass[extensible] = true;\n        generated[cacheIdentity] = GeneratedClass;\n        Object.defineProperty(\n            BaseClass,\n            cacheIdentityKey,\n            { value: cacheIdentity, writable: false }\n        );\n    }\n\n    return generated[cacheIdentity];\n};\n"]},"metadata":{},"sourceType":"module"}