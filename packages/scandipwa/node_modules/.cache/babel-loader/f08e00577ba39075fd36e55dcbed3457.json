{"ast":null,"code":"import generateApplyHandler from \"./lib/handlers/generateApplyHandler\";\nimport generateConstructHandler from \"./lib/handlers/generateConstructHandler\";\nimport generateGetHandler from \"./lib/handlers/generateGetHandler\";\nimport applyClassWrappers from \"./lib/middlewarers/generateMiddlewaredClass\";\n\nconst addNamespaceToMiddlewarable = function (Middlewarable, namespace) {\n  // Retrieve already existing namespaces\n  // Prevent mutating the namespaces of parent object\n  const namespaces = Object.assign([], Reflect.get(Middlewarable.prototype, '__namespaces__')); // Prevent duplicate namespaces for overridden classes\n\n  if (!namespaces.includes(namespace)) {\n    namespaces.push(namespace);\n  } // Set the namespaces for class\n  // eslint-disable-next-line no-param-reassign\n\n\n  Middlewarable.prototype.__namespaces__ = namespaces;\n};\n\nconst getNamespacesFromMiddlewarable = function (Middlewarable) {\n  return Middlewarable.prototype.__namespaces__;\n};\n/**\n * Middleware function is supposed to wrap source classes\n * in order to provide plugin functionality\n * @param {Function} Middlewarable\n * @param {string} namespace\n */\n\n\nfunction middleware(Middlewarable, namespace) {\n  addNamespaceToMiddlewarable(Middlewarable, namespace);\n  const handler = {\n    // Get handler for members - intercepts `get` calls, meant for class static members\n    get: generateGetHandler('class', getNamespacesFromMiddlewarable(Middlewarable)),\n    // Apply handler for functions - intercepts function calls\n    apply: generateApplyHandler(getNamespacesFromMiddlewarable(Middlewarable)),\n    // Construct handler for classes - intercepts `new` operator calls, changes properties\n    construct: generateConstructHandler(getNamespacesFromMiddlewarable(Middlewarable))\n  };\n  const proxy = new Proxy(Middlewarable, handler); // TODO check if class\n\n  return applyClassWrappers(proxy);\n}\n\nexport default middleware;","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/@scandipwa/scandipwa-extensibility/middleware.js"],"names":["generateApplyHandler","generateConstructHandler","generateGetHandler","applyClassWrappers","addNamespaceToMiddlewarable","Middlewarable","namespace","namespaces","Object","assign","Reflect","get","prototype","includes","push","__namespaces__","getNamespacesFromMiddlewarable","middleware","handler","apply","construct","proxy","Proxy"],"mappings":"AAAA,OAAOA,oBAAP;AACA,OAAOC,wBAAP;AACA,OAAOC,kBAAP;AACA,OAAOC,kBAAP;;AAEA,MAAMC,2BAA2B,GAAG,UAACC,aAAD,EAAgBC,SAAhB,EAA8B;AAC9D;AACA;AACA,QAAMC,UAAU,GAAGC,MAAM,CAACC,MAAP,CACf,EADe,EAEfC,OAAO,CAACC,GAAR,CAAYN,aAAa,CAACO,SAA1B,EAAqC,gBAArC,CAFe,CAAnB,CAH8D,CAQ9D;;AACA,MAAI,CAACL,UAAU,CAACM,QAAX,CAAoBP,SAApB,CAAL,EAAqC;AACjCC,IAAAA,UAAU,CAACO,IAAX,CAAgBR,SAAhB;AACH,GAX6D,CAa9D;AACA;;;AACAD,EAAAA,aAAa,CAACO,SAAd,CAAwBG,cAAxB,GAAyCR,UAAzC;AACH,CAhBD;;AAkBA,MAAMS,8BAA8B,GAAG,UAACX,aAAD;AAAA,SAAmBA,aAAa,CAACO,SAAd,CAAwBG,cAA3C;AAAA,CAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAoBZ,aAApB,EAAmCC,SAAnC,EAA8C;AAC1CF,EAAAA,2BAA2B,CAACC,aAAD,EAAgBC,SAAhB,CAA3B;AAEA,QAAMY,OAAO,GAAG;AACZ;AACAP,IAAAA,GAAG,EAAET,kBAAkB,CAAC,OAAD,EAAUc,8BAA8B,CAACX,aAAD,CAAxC,CAFX;AAIZ;AACAc,IAAAA,KAAK,EAAEnB,oBAAoB,CAACgB,8BAA8B,CAACX,aAAD,CAA/B,CALf;AAOZ;AACAe,IAAAA,SAAS,EAAEnB,wBAAwB,CAACe,8BAA8B,CAACX,aAAD,CAA/B;AARvB,GAAhB;AAWA,QAAMgB,KAAK,GAAG,IAAIC,KAAJ,CAAUjB,aAAV,EAAyBa,OAAzB,CAAd,CAd0C,CAgB1C;;AACA,SAAOf,kBAAkB,CAACkB,KAAD,CAAzB;AACH;;AAED,eAAeJ,UAAf","sourcesContent":["import generateApplyHandler from './lib/handlers/generateApplyHandler';\nimport generateConstructHandler from './lib/handlers/generateConstructHandler';\nimport generateGetHandler from './lib/handlers/generateGetHandler';\nimport applyClassWrappers from './lib/middlewarers/generateMiddlewaredClass';\n\nconst addNamespaceToMiddlewarable = (Middlewarable, namespace) => {\n    // Retrieve already existing namespaces\n    // Prevent mutating the namespaces of parent object\n    const namespaces = Object.assign(\n        [],\n        Reflect.get(Middlewarable.prototype, '__namespaces__')\n    );\n\n    // Prevent duplicate namespaces for overridden classes\n    if (!namespaces.includes(namespace)) {\n        namespaces.push(namespace);\n    }\n\n    // Set the namespaces for class\n    // eslint-disable-next-line no-param-reassign\n    Middlewarable.prototype.__namespaces__ = namespaces;\n};\n\nconst getNamespacesFromMiddlewarable = (Middlewarable) => Middlewarable.prototype.__namespaces__;\n\n/**\n * Middleware function is supposed to wrap source classes\n * in order to provide plugin functionality\n * @param {Function} Middlewarable\n * @param {string} namespace\n */\nfunction middleware(Middlewarable, namespace) {\n    addNamespaceToMiddlewarable(Middlewarable, namespace);\n\n    const handler = {\n        // Get handler for members - intercepts `get` calls, meant for class static members\n        get: generateGetHandler('class', getNamespacesFromMiddlewarable(Middlewarable)),\n\n        // Apply handler for functions - intercepts function calls\n        apply: generateApplyHandler(getNamespacesFromMiddlewarable(Middlewarable)),\n\n        // Construct handler for classes - intercepts `new` operator calls, changes properties\n        construct: generateConstructHandler(getNamespacesFromMiddlewarable(Middlewarable))\n    };\n\n    const proxy = new Proxy(Middlewarable, handler);\n\n    // TODO check if class\n    return applyClassWrappers(proxy);\n}\n\nexport default middleware;\n"]},"metadata":{},"sourceType":"module"}