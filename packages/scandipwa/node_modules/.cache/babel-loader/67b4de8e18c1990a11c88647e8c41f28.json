{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{DBWrapper}from'workbox-core/_private/DBWrapper.js';import{deleteDatabase}from'workbox-core/_private/deleteDatabase.js';import\"../_version.js\";var DB_NAME='workbox-expiration';var OBJECT_STORE_NAME='cache-entries';var normalizeURL=function normalizeURL(unNormalizedUrl){var url=new URL(unNormalizedUrl,location.href);url.hash='';return url.href;};/**\n * Returns the timestamp model.\n *\n * @private\n */var CacheTimestampsModel=/*#__PURE__*/function(){/**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */function CacheTimestampsModel(cacheName){var _this=this;_classCallCheck(this,CacheTimestampsModel);this._cacheName=cacheName;this._db=new DBWrapper(DB_NAME,1,{onupgradeneeded:function onupgradeneeded(event){return _this._handleUpgrade(event);}});}/**\n     * Should perform an upgrade of indexedDB.\n     *\n     * @param {Event} event\n     *\n     * @private\n     */_createClass(CacheTimestampsModel,[{key:\"_handleUpgrade\",value:function _handleUpgrade(event){var db=event.target.result;// TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n// have to use the `id` keyPath here and create our own values (a\n// concatenation of `url + cacheName`) instead of simply using\n// `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\nvar objStore=db.createObjectStore(OBJECT_STORE_NAME,{keyPath:'id'});// TODO(philipwalton): once we don't have to support EdgeHTML, we can\n// create a single index with the keyPath `['cacheName', 'timestamp']`\n// instead of doing both these indexes.\nobjStore.createIndex('cacheName','cacheName',{unique:false});objStore.createIndex('timestamp','timestamp',{unique:false});// Previous versions of `workbox-expiration` used `this._cacheName`\n// as the IDBDatabase name.\ndeleteDatabase(this._cacheName);}/**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */},{key:\"setTimestamp\",value:function(){var _setTimestamp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(url,timestamp){var entry;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:url=normalizeURL(url);entry={url:url,timestamp:timestamp,cacheName:this._cacheName,// Creating an ID from the URL and cache name won't be necessary once\n// Edge switches to Chromium and all browsers we support work with\n// array keyPaths.\nid:this._getId(url)};_context.next=4;return this._db.put(OBJECT_STORE_NAME,entry);case 4:case\"end\":return _context.stop();}}},_callee,this);}));function setTimestamp(_x,_x2){return _setTimestamp.apply(this,arguments);}return setTimestamp;}()/**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number}\n     *\n     * @private\n     */},{key:\"getTimestamp\",value:function(){var _getTimestamp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url){var entry;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this._db.get(OBJECT_STORE_NAME,this._getId(url));case 2:entry=_context2.sent;return _context2.abrupt(\"return\",entry.timestamp);case 4:case\"end\":return _context2.stop();}}},_callee2,this);}));function getTimestamp(_x3){return _getTimestamp.apply(this,arguments);}return getTimestamp;}()/**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */},{key:\"expireEntries\",value:function(){var _expireEntries=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(minTimestamp,maxCount){var _this2=this;var entriesToDelete,urlsDeleted,_iterator,_step,entry;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this._db.transaction(OBJECT_STORE_NAME,'readwrite',function(txn,done){var store=txn.objectStore(OBJECT_STORE_NAME);var request=store.index('timestamp').openCursor(null,'prev');var entriesToDelete=[];var entriesNotDeletedCount=0;request.onsuccess=function(){var cursor=request.result;if(cursor){var result=cursor.value;// TODO(philipwalton): once we can use a multi-key index, we\n// won't have to check `cacheName` here.\nif(result.cacheName===_this2._cacheName){// Delete an entry if it's older than the max age or\n// if we already have the max number allowed.\nif(minTimestamp&&result.timestamp<minTimestamp||maxCount&&entriesNotDeletedCount>=maxCount){// TODO(philipwalton): we should be able to delete the\n// entry right here, but doing so causes an iteration\n// bug in Safari stable (fixed in TP). Instead we can\n// store the keys of the entries to delete, and then\n// delete the separate transactions.\n// https://github.com/GoogleChrome/workbox/issues/1978\n// cursor.delete();\n// We only need to return the URL, not the whole entry.\nentriesToDelete.push(cursor.value);}else{entriesNotDeletedCount++;}}cursor.continue();}else{done(entriesToDelete);}};});case 2:entriesToDelete=_context3.sent;// TODO(philipwalton): once the Safari bug in the following issue is fixed,\n// we should be able to remove this loop and do the entry deletion in the\n// cursor loop above:\n// https://github.com/GoogleChrome/workbox/issues/1978\nurlsDeleted=[];_iterator=_createForOfIteratorHelper(entriesToDelete);_context3.prev=5;_iterator.s();case 7:if((_step=_iterator.n()).done){_context3.next=14;break;}entry=_step.value;_context3.next=11;return this._db.delete(OBJECT_STORE_NAME,entry.id);case 11:urlsDeleted.push(entry.url);case 12:_context3.next=7;break;case 14:_context3.next=19;break;case 16:_context3.prev=16;_context3.t0=_context3[\"catch\"](5);_iterator.e(_context3.t0);case 19:_context3.prev=19;_iterator.f();return _context3.finish(19);case 22:return _context3.abrupt(\"return\",urlsDeleted);case 23:case\"end\":return _context3.stop();}}},_callee3,this,[[5,16,19,22]]);}));function expireEntries(_x4,_x5){return _expireEntries.apply(this,arguments);}return expireEntries;}()/**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */},{key:\"_getId\",value:function _getId(url){// Creating an ID from the URL and cache name won't be necessary once\n// Edge switches to Chromium and all browsers we support work with\n// array keyPaths.\nreturn this._cacheName+'|'+normalizeURL(url);}}]);return CacheTimestampsModel;}();export{CacheTimestampsModel};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-expiration/models/CacheTimestampsModel.js"],"names":["DBWrapper","deleteDatabase","DB_NAME","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","href","hash","CacheTimestampsModel","cacheName","_cacheName","_db","onupgradeneeded","event","_handleUpgrade","db","target","result","objStore","createObjectStore","keyPath","createIndex","unique","timestamp","entry","id","_getId","put","get","minTimestamp","maxCount","transaction","txn","done","store","objectStore","request","index","openCursor","entriesToDelete","entriesNotDeletedCount","onsuccess","cursor","value","push","continue","urlsDeleted","delete"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { DBWrapper } from 'workbox-core/_private/DBWrapper.js';\nimport { deleteDatabase } from 'workbox-core/_private/deleteDatabase.js';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst OBJECT_STORE_NAME = 'cache-entries';\nconst normalizeURL = (unNormalizedUrl) => {\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = '';\n    return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheName;\n        this._db = new DBWrapper(DB_NAME, 1, {\n            onupgradeneeded: (event) => this._handleUpgrade(event),\n        });\n    }\n    /**\n     * Should perform an upgrade of indexedDB.\n     *\n     * @param {Event} event\n     *\n     * @private\n     */\n    _handleUpgrade(event) {\n        const db = event.target.result;\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\n        // Previous versions of `workbox-expiration` used `this._cacheName`\n        // as the IDBDatabase name.\n        deleteDatabase(this._cacheName);\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            url,\n            timestamp,\n            cacheName: this._cacheName,\n            // Creating an ID from the URL and cache name won't be necessary once\n            // Edge switches to Chromium and all browsers we support work with\n            // array keyPaths.\n            id: this._getId(url),\n        };\n        await this._db.put(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number}\n     *\n     * @private\n     */\n    async getTimestamp(url) {\n        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n        return entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */\n    async expireEntries(minTimestamp, maxCount) {\n        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n            const store = txn.objectStore(OBJECT_STORE_NAME);\n            const request = store.index('timestamp').openCursor(null, 'prev');\n            const entriesToDelete = [];\n            let entriesNotDeletedCount = 0;\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    const result = cursor.value;\n                    // TODO(philipwalton): once we can use a multi-key index, we\n                    // won't have to check `cacheName` here.\n                    if (result.cacheName === this._cacheName) {\n                        // Delete an entry if it's older than the max age or\n                        // if we already have the max number allowed.\n                        if ((minTimestamp && result.timestamp < minTimestamp) ||\n                            (maxCount && entriesNotDeletedCount >= maxCount)) {\n                            // TODO(philipwalton): we should be able to delete the\n                            // entry right here, but doing so causes an iteration\n                            // bug in Safari stable (fixed in TP). Instead we can\n                            // store the keys of the entries to delete, and then\n                            // delete the separate transactions.\n                            // https://github.com/GoogleChrome/workbox/issues/1978\n                            // cursor.delete();\n                            // We only need to return the URL, not the whole entry.\n                            entriesToDelete.push(cursor.value);\n                        }\n                        else {\n                            entriesNotDeletedCount++;\n                        }\n                    }\n                    cursor.continue();\n                }\n                else {\n                    done(entriesToDelete);\n                }\n            };\n        });\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n            await this._db.delete(OBJECT_STORE_NAME, entry.id);\n            urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n    _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n    }\n}\nexport { CacheTimestampsModel };\n"]},"metadata":{},"sourceType":"module"}