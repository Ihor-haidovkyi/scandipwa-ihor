{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _slicedToArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import\"../_version.js\";/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */export var DBWrapper=/*#__PURE__*/function(){/**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */function DBWrapper(name,version){var _this=this;var _ref=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},onupgradeneeded=_ref.onupgradeneeded,onversionchange=_ref.onversionchange;_classCallCheck(this,DBWrapper);this._db=null;this._name=name;this._version=version;this._onupgradeneeded=onupgradeneeded;this._onversionchange=onversionchange||function(){return _this.close();};}/**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */_createClass(DBWrapper,[{key:\"db\",get:function get(){return this._db;}/**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */},{key:\"open\",value:function(){var _open=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var _this2=this;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!this._db){_context.next=2;break;}return _context.abrupt(\"return\");case 2:_context.next=4;return new Promise(function(resolve,reject){// This flag is flipped to true if the timeout callback runs prior\n// to the request failing or succeeding. Note: we use a timeout instead\n// of an onblocked handler since there are cases where onblocked will\n// never never run. A timeout better handles all possible scenarios:\n// https://github.com/w3c/IndexedDB/issues/223\nvar openRequestTimedOut=false;setTimeout(function(){openRequestTimedOut=true;reject(new Error('The open request was blocked and timed out'));},_this2.OPEN_TIMEOUT);var openRequest=indexedDB.open(_this2._name,_this2._version);openRequest.onerror=function(){return reject(openRequest.error);};openRequest.onupgradeneeded=function(evt){if(openRequestTimedOut){openRequest.transaction.abort();openRequest.result.close();}else if(typeof _this2._onupgradeneeded==='function'){_this2._onupgradeneeded(evt);}};openRequest.onsuccess=function(){var db=openRequest.result;if(openRequestTimedOut){db.close();}else{db.onversionchange=_this2._onversionchange.bind(_this2);resolve(db);}};});case 4:this._db=_context.sent;return _context.abrupt(\"return\",this);case 6:case\"end\":return _context.stop();}}},_callee,this);}));function open(){return _open.apply(this,arguments);}return open;}()/**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */},{key:\"getKey\",value:function(){var _getKey=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(storeName,query){return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return this.getAllKeys(storeName,query,1);case 2:return _context2.abrupt(\"return\",_context2.sent[0]);case 3:case\"end\":return _context2.stop();}}},_callee2,this);}));function getKey(_x,_x2){return _getKey.apply(this,arguments);}return getKey;}()/**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */},{key:\"getAll\",value:function(){var _getAll=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(storeName,query,count){return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return this.getAllMatching(storeName,{query:query,count:count});case 2:return _context3.abrupt(\"return\",_context3.sent);case 3:case\"end\":return _context3.stop();}}},_callee3,this);}));function getAll(_x3,_x4,_x5){return _getAll.apply(this,arguments);}return getAll;}()/**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */},{key:\"getAllKeys\",value:function(){var _getAllKeys=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(storeName,query,count){var entries;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return this.getAllMatching(storeName,{query:query,count:count,includeKeys:true});case 2:entries=_context4.sent;return _context4.abrupt(\"return\",entries.map(function(entry){return entry.key;}));case 4:case\"end\":return _context4.stop();}}},_callee4,this);}));function getAllKeys(_x6,_x7,_x8){return _getAllKeys.apply(this,arguments);}return getAllKeys;}()/**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */},{key:\"getAllMatching\",value:function(){var _getAllMatching=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(storeName){var _ref2,index,_ref2$query,query,_ref2$direction,direction,count,_ref2$includeKeys,includeKeys,_args5=arguments;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_ref2=_args5.length>1&&_args5[1]!==undefined?_args5[1]:{},index=_ref2.index,_ref2$query=_ref2.query,query=_ref2$query===void 0?null:_ref2$query,_ref2$direction=_ref2.direction,direction=_ref2$direction===void 0?'next':_ref2$direction,count=_ref2.count,_ref2$includeKeys=_ref2.includeKeys,includeKeys=_ref2$includeKeys===void 0?false:_ref2$includeKeys;_context5.next=3;return this.transaction([storeName],'readonly',function(txn,done){var store=txn.objectStore(storeName);var target=index?store.index(index):store;var results=[];var request=target.openCursor(query,direction);request.onsuccess=function(){var cursor=request.result;if(cursor){results.push(includeKeys?cursor:cursor.value);if(count&&results.length>=count){done(results);}else{cursor.continue();}}else{done(results);}};});case 3:return _context5.abrupt(\"return\",_context5.sent);case 4:case\"end\":return _context5.stop();}}},_callee5,this);}));function getAllMatching(_x9){return _getAllMatching.apply(this,arguments);}return getAllMatching;}()/**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */},{key:\"transaction\",value:function(){var _transaction=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(storeNames,type,callback){var _this3=this;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return this.open();case 2:_context6.next=4;return new Promise(function(resolve,reject){var txn=_this3._db.transaction(storeNames,type);txn.onabort=function(){return reject(txn.error);};txn.oncomplete=function(){return resolve();};callback(txn,function(value){return resolve(value);});});case 4:return _context6.abrupt(\"return\",_context6.sent);case 5:case\"end\":return _context6.stop();}}},_callee6,this);}));function transaction(_x10,_x11,_x12){return _transaction.apply(this,arguments);}return transaction;}()/**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */},{key:\"_call\",value:function(){var _call2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(method,storeName,type){var _len,args,_key,callback,_args7=arguments;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:for(_len=_args7.length,args=new Array(_len>3?_len-3:0),_key=3;_key<_len;_key++){args[_key-3]=_args7[_key];}callback=function callback(txn,done){var objStore=txn.objectStore(storeName);// TODO(philipwalton): Fix this underlying TS2684 error.\n// @ts-ignore\nvar request=objStore[method].apply(objStore,args);request.onsuccess=function(){return done(request.result);};};_context7.next=4;return this.transaction([storeName],type,callback);case 4:return _context7.abrupt(\"return\",_context7.sent);case 5:case\"end\":return _context7.stop();}}},_callee7,this);}));function _call(_x13,_x14,_x15){return _call2.apply(this,arguments);}return _call;}()/**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */},{key:\"close\",value:function close(){if(this._db){this._db.close();this._db=null;}}}]);return DBWrapper;}();// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT=2000;// Wrap native IDBObjectStore methods according to their mode.\nvar methodsToWrap={readonly:['get','count','getKey','getAll','getAllKeys'],readwrite:['add','put','clear','delete']};var _loop=function _loop(){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),mode=_Object$entries$_i[0],methods=_Object$entries$_i[1];var _iterator=_createForOfIteratorHelper(methods),_step;try{var _loop2=function _loop2(){var method=_step.value;if(method in IDBObjectStore.prototype){// Don't use arrow functions here since we're outside of the class.\nDBWrapper.prototype[method]=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(storeName){var _len2,args,_key2,_args8=arguments;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:for(_len2=_args8.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=_args8[_key2];}_context8.next=3;return this._call.apply(this,[method,storeName,mode].concat(args));case 3:return _context8.abrupt(\"return\",_context8.sent);case 4:case\"end\":return _context8.stop();}}},_callee8,this);}));return function(_x16){return _ref3.apply(this,arguments);};}();}};for(_iterator.s();!(_step=_iterator.n()).done;){_loop2();}}catch(err){_iterator.e(err);}finally{_iterator.f();}};for(var _i=0,_Object$entries=Object.entries(methodsToWrap);_i<_Object$entries.length;_i++){_loop();}","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-core/_private/DBWrapper.js"],"names":["DBWrapper","name","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","Promise","resolve","reject","openRequestTimedOut","setTimeout","Error","OPEN_TIMEOUT","openRequest","indexedDB","open","onerror","error","evt","transaction","abort","result","onsuccess","db","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","entries","map","entry","key","index","direction","txn","done","store","objectStore","target","results","request","openCursor","cursor","push","value","length","continue","storeNames","type","callback","onabort","oncomplete","method","args","objStore","apply","prototype","methodsToWrap","readonly","readwrite","mode","methods","IDBObjectStore","_call","Object"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            // TODO(philipwalton): Fix this underlying TS2684 error.\n            // @ts-ignore\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}