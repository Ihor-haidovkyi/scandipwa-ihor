{"ast":null,"code":"import generateApplyHandler from\"./lib/handlers/generateApplyHandler\";import generateConstructHandler from\"./lib/handlers/generateConstructHandler\";import generateGetHandler from\"./lib/handlers/generateGetHandler\";import applyClassWrappers from\"./lib/middlewarers/generateMiddlewaredClass\";var addNamespaceToMiddlewarable=function addNamespaceToMiddlewarable(Middlewarable,namespace){// Retrieve already existing namespaces\n// Prevent mutating the namespaces of parent object\nvar namespaces=Object.assign([],Reflect.get(Middlewarable.prototype,'__namespaces__'));// Prevent duplicate namespaces for overridden classes\nif(!namespaces.includes(namespace)){namespaces.push(namespace);}// Set the namespaces for class\n// eslint-disable-next-line no-param-reassign\nMiddlewarable.prototype.__namespaces__=namespaces;};var getNamespacesFromMiddlewarable=function getNamespacesFromMiddlewarable(Middlewarable){return Middlewarable.prototype.__namespaces__;};/**\n * Middleware function is supposed to wrap source classes\n * in order to provide plugin functionality\n * @param {Function} Middlewarable\n * @param {string} namespace\n */function middleware(Middlewarable,namespace){addNamespaceToMiddlewarable(Middlewarable,namespace);var handler={// Get handler for members - intercepts `get` calls, meant for class static members\nget:generateGetHandler('class',getNamespacesFromMiddlewarable(Middlewarable)),// Apply handler for functions - intercepts function calls\napply:generateApplyHandler(getNamespacesFromMiddlewarable(Middlewarable)),// Construct handler for classes - intercepts `new` operator calls, changes properties\nconstruct:generateConstructHandler(getNamespacesFromMiddlewarable(Middlewarable))};var proxy=new Proxy(Middlewarable,handler);// TODO check if class\nreturn applyClassWrappers(proxy);}export default middleware;","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/@scandipwa/scandipwa-extensibility/middleware.js"],"names":["generateApplyHandler","generateConstructHandler","generateGetHandler","applyClassWrappers","addNamespaceToMiddlewarable","Middlewarable","namespace","namespaces","Object","assign","Reflect","get","prototype","includes","push","__namespaces__","getNamespacesFromMiddlewarable","middleware","handler","apply","construct","proxy","Proxy"],"mappings":"AAAA,MAAOA,CAAAA,oBAAP,2CACA,MAAOC,CAAAA,wBAAP,+CACA,MAAOC,CAAAA,kBAAP,yCACA,MAAOC,CAAAA,kBAAP,mDAEA,GAAMC,CAAAA,2BAA2B,CAAG,QAA9BA,CAAAA,2BAA8B,CAACC,aAAD,CAAgBC,SAAhB,CAA8B,CAC9D;AACA;AACA,GAAMC,CAAAA,UAAU,CAAGC,MAAM,CAACC,MAAP,CACf,EADe,CAEfC,OAAO,CAACC,GAAR,CAAYN,aAAa,CAACO,SAA1B,CAAqC,gBAArC,CAFe,CAAnB,CAKA;AACA,GAAI,CAACL,UAAU,CAACM,QAAX,CAAoBP,SAApB,CAAL,CAAqC,CACjCC,UAAU,CAACO,IAAX,CAAgBR,SAAhB,EACH,CAED;AACA;AACAD,aAAa,CAACO,SAAd,CAAwBG,cAAxB,CAAyCR,UAAzC,CACH,CAhBD,CAkBA,GAAMS,CAAAA,8BAA8B,CAAG,QAAjCA,CAAAA,8BAAiC,CAACX,aAAD,QAAmBA,CAAAA,aAAa,CAACO,SAAd,CAAwBG,cAA3C,EAAvC,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,QAASE,CAAAA,UAAT,CAAoBZ,aAApB,CAAmCC,SAAnC,CAA8C,CAC1CF,2BAA2B,CAACC,aAAD,CAAgBC,SAAhB,CAA3B,CAEA,GAAMY,CAAAA,OAAO,CAAG,CACZ;AACAP,GAAG,CAAET,kBAAkB,CAAC,OAAD,CAAUc,8BAA8B,CAACX,aAAD,CAAxC,CAFX,CAIZ;AACAc,KAAK,CAAEnB,oBAAoB,CAACgB,8BAA8B,CAACX,aAAD,CAA/B,CALf,CAOZ;AACAe,SAAS,CAAEnB,wBAAwB,CAACe,8BAA8B,CAACX,aAAD,CAA/B,CARvB,CAAhB,CAWA,GAAMgB,CAAAA,KAAK,CAAG,GAAIC,CAAAA,KAAJ,CAAUjB,aAAV,CAAyBa,OAAzB,CAAd,CAEA;AACA,MAAOf,CAAAA,kBAAkB,CAACkB,KAAD,CAAzB,CACH,CAED,cAAeJ,CAAAA,UAAf","sourcesContent":["import generateApplyHandler from './lib/handlers/generateApplyHandler';\nimport generateConstructHandler from './lib/handlers/generateConstructHandler';\nimport generateGetHandler from './lib/handlers/generateGetHandler';\nimport applyClassWrappers from './lib/middlewarers/generateMiddlewaredClass';\n\nconst addNamespaceToMiddlewarable = (Middlewarable, namespace) => {\n    // Retrieve already existing namespaces\n    // Prevent mutating the namespaces of parent object\n    const namespaces = Object.assign(\n        [],\n        Reflect.get(Middlewarable.prototype, '__namespaces__')\n    );\n\n    // Prevent duplicate namespaces for overridden classes\n    if (!namespaces.includes(namespace)) {\n        namespaces.push(namespace);\n    }\n\n    // Set the namespaces for class\n    // eslint-disable-next-line no-param-reassign\n    Middlewarable.prototype.__namespaces__ = namespaces;\n};\n\nconst getNamespacesFromMiddlewarable = (Middlewarable) => Middlewarable.prototype.__namespaces__;\n\n/**\n * Middleware function is supposed to wrap source classes\n * in order to provide plugin functionality\n * @param {Function} Middlewarable\n * @param {string} namespace\n */\nfunction middleware(Middlewarable, namespace) {\n    addNamespaceToMiddlewarable(Middlewarable, namespace);\n\n    const handler = {\n        // Get handler for members - intercepts `get` calls, meant for class static members\n        get: generateGetHandler('class', getNamespacesFromMiddlewarable(Middlewarable)),\n\n        // Apply handler for functions - intercepts function calls\n        apply: generateApplyHandler(getNamespacesFromMiddlewarable(Middlewarable)),\n\n        // Construct handler for classes - intercepts `new` operator calls, changes properties\n        construct: generateConstructHandler(getNamespacesFromMiddlewarable(Middlewarable))\n    };\n\n    const proxy = new Proxy(Middlewarable, handler);\n\n    // TODO check if class\n    return applyClassWrappers(proxy);\n}\n\nexport default middleware;\n"]},"metadata":{},"sourceType":"module"}