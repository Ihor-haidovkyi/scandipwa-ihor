{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _construct from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";import _toConsumableArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{getFriendlyURL}from'workbox-core/_private/getFriendlyURL.js';import{normalizeHandler}from\"./utils/normalizeHandler.js\";import\"./_version.js\";/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */var Router=/*#__PURE__*/function(){/**\n     * Initializes a new Router.\n     */function Router(){_classCallCheck(this,Router);this._routes=new Map();}/**\n     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */_createClass(Router,[{key:\"routes\",get:function get(){return this._routes;}/**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */},{key:\"addFetchListener\",value:function addFetchListener(){var _this=this;// See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\nself.addEventListener('fetch',function(event){var request=event.request;var responsePromise=_this.handleRequest({request:request,event:event});if(responsePromise){event.respondWith(responsePromise);}});}/**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */},{key:\"addCacheListener\",value:function addCacheListener(){var _this2=this;// See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\nself.addEventListener('message',function(event){if(event.data&&event.data.type==='CACHE_URLS'){var payload=event.data.payload;if(process.env.NODE_ENV!=='production'){logger.debug(\"Caching URLs from the window\",payload.urlsToCache);}var requestPromises=Promise.all(payload.urlsToCache.map(function(entry){if(typeof entry==='string'){entry=[entry];}var request=_construct(Request,_toConsumableArray(entry));return _this2.handleRequest({request:request});// TODO(philipwalton): TypeScript errors without this typecast for\n// some reason (probably a bug). The real type here should work but\n// doesn't: `Array<Promise<Response> | undefined>`.\n}));// TypeScript\nevent.waitUntil(requestPromises);// If a MessageChannel was used, reply to the message on success.\nif(event.ports&&event.ports[0]){requestPromises.then(function(){return event.ports[0].postMessage(true);});}}});}/**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */},{key:\"handleRequest\",value:function handleRequest(_ref){var _this3=this;var request=_ref.request,event=_ref.event;if(process.env.NODE_ENV!=='production'){assert.isInstance(request,Request,{moduleName:'workbox-routing',className:'Router',funcName:'handleRequest',paramName:'options.request'});}var url=new URL(request.url,location.href);if(!url.protocol.startsWith('http')){if(process.env.NODE_ENV!=='production'){logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");}return;}var _this$findMatchingRou=this.findMatchingRoute({url:url,request:request,event:event}),params=_this$findMatchingRou.params,route=_this$findMatchingRou.route;var handler=route&&route.handler;var debugMessages=[];if(process.env.NODE_ENV!=='production'){if(handler){debugMessages.push([\"Found a route to handle this request:\",route]);if(params){debugMessages.push([\"Passing the following params to the route's handler:\",params]);}}}// If we don't have a handler because there was no matching route, then\n// fall back to defaultHandler if that's defined.\nif(!handler&&this._defaultHandler){if(process.env.NODE_ENV!=='production'){debugMessages.push(\"Failed to find a matching route. Falling \"+\"back to the default handler.\");}handler=this._defaultHandler;}if(!handler){if(process.env.NODE_ENV!=='production'){// No handler so Workbox will do nothing. If logs is set of debug\n// i.e. verbose, we should print out this information.\nlogger.debug(\"No route found for: \".concat(getFriendlyURL(url)));}return;}if(process.env.NODE_ENV!=='production'){// We have a handler, meaning Workbox is going to handle the route.\n// print the routing details to the console.\nlogger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));debugMessages.forEach(function(msg){if(Array.isArray(msg)){logger.log.apply(logger,_toConsumableArray(msg));}else{logger.log(msg);}});logger.groupEnd();}// Wrap in try and catch in case the handle method throws a synchronous\n// error. It should still callback to the catch handler.\nvar responsePromise;try{responsePromise=handler.handle({url:url,request:request,event:event,params:params});}catch(err){responsePromise=Promise.reject(err);}if(responsePromise instanceof Promise&&this._catchHandler){responsePromise=responsePromise.catch(function(err){if(process.env.NODE_ENV!=='production'){// Still include URL here as it will be async from the console group\n// and may not make sense without the URL\nlogger.groupCollapsed(\"Error thrown when responding to: \"+\" \".concat(getFriendlyURL(url),\". Falling back to Catch Handler.\"));logger.error(\"Error thrown by:\",route);logger.error(err);logger.groupEnd();}return _this3._catchHandler.handle({url:url,request:request,event:event});});}return responsePromise;}/**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */},{key:\"findMatchingRoute\",value:function findMatchingRoute(_ref2){var url=_ref2.url,request=_ref2.request,event=_ref2.event;if(process.env.NODE_ENV!=='production'){assert.isInstance(url,URL,{moduleName:'workbox-routing',className:'Router',funcName:'findMatchingRoute',paramName:'options.url'});assert.isInstance(request,Request,{moduleName:'workbox-routing',className:'Router',funcName:'findMatchingRoute',paramName:'options.request'});}var routes=this._routes.get(request.method)||[];var _iterator=_createForOfIteratorHelper(routes),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var route=_step.value;var params=void 0;var matchResult=route.match({url:url,request:request,event:event});if(matchResult){// See https://github.com/GoogleChrome/workbox/issues/2079\nparams=matchResult;if(Array.isArray(matchResult)&&matchResult.length===0){// Instead of passing an empty array in as params, use undefined.\nparams=undefined;}else if(matchResult.constructor===Object&&Object.keys(matchResult).length===0){// Instead of passing an empty object in as params, use undefined.\nparams=undefined;}else if(typeof matchResult==='boolean'){// For the boolean value true (rather than just something truth-y),\n// don't set params.\n// See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\nparams=undefined;}// Return early if have a match.\nreturn{route:route,params:params};}}// If no match was found above, return and empty object.\n}catch(err){_iterator.e(err);}finally{_iterator.f();}return{};}/**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */},{key:\"setDefaultHandler\",value:function setDefaultHandler(handler){this._defaultHandler=normalizeHandler(handler);}/**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */},{key:\"setCatchHandler\",value:function setCatchHandler(handler){this._catchHandler=normalizeHandler(handler);}/**\n     * Registers a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to register.\n     */},{key:\"registerRoute\",value:function registerRoute(route){if(process.env.NODE_ENV!=='production'){assert.isType(route,'object',{moduleName:'workbox-routing',className:'Router',funcName:'registerRoute',paramName:'route'});assert.hasMethod(route,'match',{moduleName:'workbox-routing',className:'Router',funcName:'registerRoute',paramName:'route'});assert.isType(route.handler,'object',{moduleName:'workbox-routing',className:'Router',funcName:'registerRoute',paramName:'route'});assert.hasMethod(route.handler,'handle',{moduleName:'workbox-routing',className:'Router',funcName:'registerRoute',paramName:'route.handler'});assert.isType(route.method,'string',{moduleName:'workbox-routing',className:'Router',funcName:'registerRoute',paramName:'route.method'});}if(!this._routes.has(route.method)){this._routes.set(route.method,[]);}// Give precedence to all of the earlier routes by adding this additional\n// route to the end of the array.\nthis._routes.get(route.method).push(route);}/**\n     * Unregisters a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to unregister.\n     */},{key:\"unregisterRoute\",value:function unregisterRoute(route){if(!this._routes.has(route.method)){throw new WorkboxError('unregister-route-but-not-found-with-method',{method:route.method});}var routeIndex=this._routes.get(route.method).indexOf(route);if(routeIndex>-1){this._routes.get(route.method).splice(routeIndex,1);}else{throw new WorkboxError('unregister-route-route-not-registered');}}}]);return Router;}();export{Router};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-routing/Router.js"],"names":["assert","logger","WorkboxError","getFriendlyURL","normalizeHandler","Router","_routes","Map","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","findMatchingRoute","params","route","handler","debugMessages","push","_defaultHandler","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","_catchHandler","catch","error","routes","get","method","matchResult","match","length","undefined","constructor","Object","keys","isType","hasMethod","has","set","routeIndex","indexOf","splice"],"mappings":"2uBAAA;AACA;AACA;AACA;AACA;AACA;AACA,EACA,OAASA,MAAT,KAAuB,iCAAvB,CACA,OAASC,MAAT,KAAuB,iCAAvB,CACA,OAASC,YAAT,KAA6B,uCAA7B,CACA,OAASC,cAAT,KAA+B,yCAA/B,CACA,OAASC,gBAAT,mCACA,sBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,GACMC,CAAAA,M,yBACF;AACJ;AACA,OACI,iBAAc,8BACV,KAAKC,OAAL,CAAe,GAAIC,CAAAA,GAAJ,EAAf,CACH,CACD;AACJ;AACA;AACA;AACA,O,uCACI,cAAa,CACT,MAAO,MAAKD,OAAZ,CACH,CACD;AACJ;AACA;AACA,O,gCACI,2BAAmB,gBACf;AACAE,IAAI,CAACC,gBAAL,CAAsB,OAAtB,CAAgC,SAACC,KAAD,CAAW,IAC/BC,CAAAA,OAD+B,CACnBD,KADmB,CAC/BC,OAD+B,CAEvC,GAAMC,CAAAA,eAAe,CAAG,KAAI,CAACC,aAAL,CAAmB,CAAEF,OAAO,CAAPA,OAAF,CAAWD,KAAK,CAALA,KAAX,CAAnB,CAAxB,CACA,GAAIE,eAAJ,CAAqB,CACjBF,KAAK,CAACI,WAAN,CAAkBF,eAAlB,EACH,CACJ,CAND,EAOH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,gCACI,2BAAmB,iBACf;AACAJ,IAAI,CAACC,gBAAL,CAAsB,SAAtB,CAAkC,SAACC,KAAD,CAAW,CACzC,GAAIA,KAAK,CAACK,IAAN,EAAcL,KAAK,CAACK,IAAN,CAAWC,IAAX,GAAoB,YAAtC,CAAoD,IACxCC,CAAAA,OADwC,CAC5BP,KAAK,CAACK,IADsB,CACxCE,OADwC,CAEhD,GAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCnB,MAAM,CAACoB,KAAP,gCAA6CJ,OAAO,CAACK,WAArD,EACH,CACD,GAAMC,CAAAA,eAAe,CAAGC,OAAO,CAACC,GAAR,CAAYR,OAAO,CAACK,WAAR,CAAoBI,GAApB,CAAwB,SAACC,KAAD,CAAW,CACnE,GAAI,MAAOA,CAAAA,KAAP,GAAiB,QAArB,CAA+B,CAC3BA,KAAK,CAAG,CAACA,KAAD,CAAR,CACH,CACD,GAAMhB,CAAAA,OAAO,YAAOiB,OAAP,oBAAkBD,KAAlB,EAAb,CACA,MAAO,CAAA,MAAI,CAACd,aAAL,CAAmB,CAAEF,OAAO,CAAPA,OAAF,CAAnB,CAAP,CACA;AACA;AACA;AACH,CATmC,CAAZ,CAAxB,CASK;AACLD,KAAK,CAACmB,SAAN,CAAgBN,eAAhB,EACA;AACA,GAAIb,KAAK,CAACoB,KAAN,EAAepB,KAAK,CAACoB,KAAN,CAAY,CAAZ,CAAnB,CAAmC,CAC/BP,eAAe,CAACQ,IAAhB,CAAqB,iBAAMrB,CAAAA,KAAK,CAACoB,KAAN,CAAY,CAAZ,EAAeE,WAAf,CAA2B,IAA3B,CAAN,EAArB,EACH,CACJ,CACJ,CAtBD,EAuBH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,6BACI,4BAAkC,oBAAlBrB,CAAAA,OAAkB,MAAlBA,OAAkB,CAATD,KAAS,MAATA,KAAS,CAC9B,GAAIQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCpB,MAAM,CAACiC,UAAP,CAAkBtB,OAAlB,CAA2BiB,OAA3B,CAAoC,CAChCM,UAAU,CAAE,iBADoB,CAEhCC,SAAS,CAAE,QAFqB,CAGhCC,QAAQ,CAAE,eAHsB,CAIhCC,SAAS,CAAE,iBAJqB,CAApC,EAMH,CACD,GAAMC,CAAAA,GAAG,CAAG,GAAIC,CAAAA,GAAJ,CAAQ5B,OAAO,CAAC2B,GAAhB,CAAqBE,QAAQ,CAACC,IAA9B,CAAZ,CACA,GAAI,CAACH,GAAG,CAACI,QAAJ,CAAaC,UAAb,CAAwB,MAAxB,CAAL,CAAsC,CAClC,GAAIzB,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCnB,MAAM,CAACoB,KAAP,8DACH,CACD,OACH,CAf6B,0BAgBJ,KAAKuB,iBAAL,CAAuB,CAAEN,GAAG,CAAHA,GAAF,CAAO3B,OAAO,CAAPA,OAAP,CAAgBD,KAAK,CAALA,KAAhB,CAAvB,CAhBI,CAgBtBmC,MAhBsB,uBAgBtBA,MAhBsB,CAgBdC,KAhBc,uBAgBdA,KAhBc,CAiB9B,GAAIC,CAAAA,OAAO,CAAGD,KAAK,EAAIA,KAAK,CAACC,OAA7B,CACA,GAAMC,CAAAA,aAAa,CAAG,EAAtB,CACA,GAAI9B,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC,GAAI2B,OAAJ,CAAa,CACTC,aAAa,CAACC,IAAd,CAAmB,yCAC0BH,KAD1B,CAAnB,EAGA,GAAID,MAAJ,CAAY,CACRG,aAAa,CAACC,IAAd,CAAmB,wDACyCJ,MADzC,CAAnB,EAGH,CACJ,CACJ,CACD;AACA;AACA,GAAI,CAACE,OAAD,EAAY,KAAKG,eAArB,CAAsC,CAClC,GAAIhC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC4B,aAAa,CAACC,IAAd,CAAmB,0EAAnB,EAEH,CACDF,OAAO,CAAG,KAAKG,eAAf,CACH,CACD,GAAI,CAACH,OAAL,CAAc,CACV,GAAI7B,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC;AACA;AACAnB,MAAM,CAACoB,KAAP,+BAAoClB,cAAc,CAACmC,GAAD,CAAlD,GACH,CACD,OACH,CACD,GAAIpB,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC;AACA;AACAnB,MAAM,CAACkD,cAAP,oCAAkDhD,cAAc,CAACmC,GAAD,CAAhE,GACAU,aAAa,CAACI,OAAd,CAAsB,SAACC,GAAD,CAAS,CAC3B,GAAIC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAJ,CAAwB,CACpBpD,MAAM,CAACuD,GAAP,OAAAvD,MAAM,oBAAQoD,GAAR,EAAN,CACH,CAFD,IAGK,CACDpD,MAAM,CAACuD,GAAP,CAAWH,GAAX,EACH,CACJ,CAPD,EAQApD,MAAM,CAACwD,QAAP,GACH,CACD;AACA;AACA,GAAI7C,CAAAA,eAAJ,CACA,GAAI,CACAA,eAAe,CAAGmC,OAAO,CAACW,MAAR,CAAe,CAAEpB,GAAG,CAAHA,GAAF,CAAO3B,OAAO,CAAPA,OAAP,CAAgBD,KAAK,CAALA,KAAhB,CAAuBmC,MAAM,CAANA,MAAvB,CAAf,CAAlB,CACH,CACD,MAAOc,GAAP,CAAY,CACR/C,eAAe,CAAGY,OAAO,CAACoC,MAAR,CAAeD,GAAf,CAAlB,CACH,CACD,GAAI/C,eAAe,WAAYY,CAAAA,OAA3B,EAAsC,KAAKqC,aAA/C,CAA8D,CAC1DjD,eAAe,CAAGA,eAAe,CAACkD,KAAhB,CAAsB,SAACH,GAAD,CAAS,CAC7C,GAAIzC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC;AACA;AACAnB,MAAM,CAACkD,cAAP,CAAsB,+CACdhD,cAAc,CAACmC,GAAD,CADA,oCAAtB,EAEArC,MAAM,CAAC8D,KAAP,oBAAiCjB,KAAjC,EACA7C,MAAM,CAAC8D,KAAP,CAAaJ,GAAb,EACA1D,MAAM,CAACwD,QAAP,GACH,CACD,MAAO,CAAA,MAAI,CAACI,aAAL,CAAmBH,MAAnB,CAA0B,CAAEpB,GAAG,CAAHA,GAAF,CAAO3B,OAAO,CAAPA,OAAP,CAAgBD,KAAK,CAALA,KAAhB,CAA1B,CAAP,CACH,CAXiB,CAAlB,CAYH,CACD,MAAOE,CAAAA,eAAP,CACH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,iCACI,iCAA2C,IAAvB0B,CAAAA,GAAuB,OAAvBA,GAAuB,CAAlB3B,OAAkB,OAAlBA,OAAkB,CAATD,KAAS,OAATA,KAAS,CACvC,GAAIQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCpB,MAAM,CAACiC,UAAP,CAAkBK,GAAlB,CAAuBC,GAAvB,CAA4B,CACxBL,UAAU,CAAE,iBADY,CAExBC,SAAS,CAAE,QAFa,CAGxBC,QAAQ,CAAE,mBAHc,CAIxBC,SAAS,CAAE,aAJa,CAA5B,EAMArC,MAAM,CAACiC,UAAP,CAAkBtB,OAAlB,CAA2BiB,OAA3B,CAAoC,CAChCM,UAAU,CAAE,iBADoB,CAEhCC,SAAS,CAAE,QAFqB,CAGhCC,QAAQ,CAAE,mBAHsB,CAIhCC,SAAS,CAAE,iBAJqB,CAApC,EAMH,CACD,GAAM2B,CAAAA,MAAM,CAAG,KAAK1D,OAAL,CAAa2D,GAAb,CAAiBtD,OAAO,CAACuD,MAAzB,GAAoC,EAAnD,CAfuC,yCAgBnBF,MAhBmB,YAgBvC,+CAA4B,IAAjBlB,CAAAA,KAAiB,aACxB,GAAID,CAAAA,MAAM,OAAV,CACA,GAAMsB,CAAAA,WAAW,CAAGrB,KAAK,CAACsB,KAAN,CAAY,CAAE9B,GAAG,CAAHA,GAAF,CAAO3B,OAAO,CAAPA,OAAP,CAAgBD,KAAK,CAALA,KAAhB,CAAZ,CAApB,CACA,GAAIyD,WAAJ,CAAiB,CACb;AACAtB,MAAM,CAAGsB,WAAT,CACA,GAAIb,KAAK,CAACC,OAAN,CAAcY,WAAd,GAA8BA,WAAW,CAACE,MAAZ,GAAuB,CAAzD,CAA4D,CACxD;AACAxB,MAAM,CAAGyB,SAAT,CACH,CAHD,IAIK,IAAKH,WAAW,CAACI,WAAZ,GAA4BC,MAA5B,EACNA,MAAM,CAACC,IAAP,CAAYN,WAAZ,EAAyBE,MAAzB,GAAoC,CADnC,CACuC,CACxC;AACAxB,MAAM,CAAGyB,SAAT,CACH,CAJI,IAKA,IAAI,MAAOH,CAAAA,WAAP,GAAuB,SAA3B,CAAsC,CACvC;AACA;AACA;AACAtB,MAAM,CAAGyB,SAAT,CACH,CACD;AACA,MAAO,CAAExB,KAAK,CAALA,KAAF,CAASD,MAAM,CAANA,MAAT,CAAP,CACH,CACJ,CACD;AAzCuC,qDA0CvC,MAAO,EAAP,CACH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O,iCACI,2BAAkBE,OAAlB,CAA2B,CACvB,KAAKG,eAAL,CAAuB9C,gBAAgB,CAAC2C,OAAD,CAAvC,CACH,CACD;AACJ;AACA;AACA;AACA;AACA;AACA,O,+BACI,yBAAgBA,OAAhB,CAAyB,CACrB,KAAKc,aAAL,CAAqBzD,gBAAgB,CAAC2C,OAAD,CAArC,CACH,CACD;AACJ;AACA;AACA;AACA,O,6BACI,uBAAcD,KAAd,CAAqB,CACjB,GAAI5B,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCpB,MAAM,CAAC0E,MAAP,CAAc5B,KAAd,CAAqB,QAArB,CAA+B,CAC3BZ,UAAU,CAAE,iBADe,CAE3BC,SAAS,CAAE,QAFgB,CAG3BC,QAAQ,CAAE,eAHiB,CAI3BC,SAAS,CAAE,OAJgB,CAA/B,EAMArC,MAAM,CAAC2E,SAAP,CAAiB7B,KAAjB,CAAwB,OAAxB,CAAiC,CAC7BZ,UAAU,CAAE,iBADiB,CAE7BC,SAAS,CAAE,QAFkB,CAG7BC,QAAQ,CAAE,eAHmB,CAI7BC,SAAS,CAAE,OAJkB,CAAjC,EAMArC,MAAM,CAAC0E,MAAP,CAAc5B,KAAK,CAACC,OAApB,CAA6B,QAA7B,CAAuC,CACnCb,UAAU,CAAE,iBADuB,CAEnCC,SAAS,CAAE,QAFwB,CAGnCC,QAAQ,CAAE,eAHyB,CAInCC,SAAS,CAAE,OAJwB,CAAvC,EAMArC,MAAM,CAAC2E,SAAP,CAAiB7B,KAAK,CAACC,OAAvB,CAAgC,QAAhC,CAA0C,CACtCb,UAAU,CAAE,iBAD0B,CAEtCC,SAAS,CAAE,QAF2B,CAGtCC,QAAQ,CAAE,eAH4B,CAItCC,SAAS,CAAE,eAJ2B,CAA1C,EAMArC,MAAM,CAAC0E,MAAP,CAAc5B,KAAK,CAACoB,MAApB,CAA4B,QAA5B,CAAsC,CAClChC,UAAU,CAAE,iBADsB,CAElCC,SAAS,CAAE,QAFuB,CAGlCC,QAAQ,CAAE,eAHwB,CAIlCC,SAAS,CAAE,cAJuB,CAAtC,EAMH,CACD,GAAI,CAAC,KAAK/B,OAAL,CAAasE,GAAb,CAAiB9B,KAAK,CAACoB,MAAvB,CAAL,CAAqC,CACjC,KAAK5D,OAAL,CAAauE,GAAb,CAAiB/B,KAAK,CAACoB,MAAvB,CAA+B,EAA/B,EACH,CACD;AACA;AACA,KAAK5D,OAAL,CAAa2D,GAAb,CAAiBnB,KAAK,CAACoB,MAAvB,EAA+BjB,IAA/B,CAAoCH,KAApC,EACH,CACD;AACJ;AACA;AACA;AACA,O,+BACI,yBAAgBA,KAAhB,CAAuB,CACnB,GAAI,CAAC,KAAKxC,OAAL,CAAasE,GAAb,CAAiB9B,KAAK,CAACoB,MAAvB,CAAL,CAAqC,CACjC,KAAM,IAAIhE,CAAAA,YAAJ,CAAiB,4CAAjB,CAA+D,CACjEgE,MAAM,CAAEpB,KAAK,CAACoB,MADmD,CAA/D,CAAN,CAGH,CACD,GAAMY,CAAAA,UAAU,CAAG,KAAKxE,OAAL,CAAa2D,GAAb,CAAiBnB,KAAK,CAACoB,MAAvB,EAA+Ba,OAA/B,CAAuCjC,KAAvC,CAAnB,CACA,GAAIgC,UAAU,CAAG,CAAC,CAAlB,CAAqB,CACjB,KAAKxE,OAAL,CAAa2D,GAAb,CAAiBnB,KAAK,CAACoB,MAAvB,EAA+Bc,MAA/B,CAAsCF,UAAtC,CAAkD,CAAlD,EACH,CAFD,IAGK,CACD,KAAM,IAAI5E,CAAAA,YAAJ,CAAiB,uCAAjB,CAAN,CACH,CACJ,C,sBAEL,OAASG,MAAT","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n    }\n    /**\n     * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const { params, route } = this.findMatchingRoute({ url, request, event });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([\n                    `Found a route to handle this request:`, route,\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`, params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        if (!handler && this._defaultHandler) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler.`);\n            }\n            handler = this._defaultHandler;\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        if (responsePromise instanceof Promise && this._catchHandler) {\n            responsePromise = responsePromise.catch((err) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(`Error thrown when responding to: ` +\n                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n                    logger.error(`Error thrown by:`, route);\n                    logger.error(err);\n                    logger.groupEnd();\n                }\n                return this._catchHandler.handle({ url, request, event });\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(url, URL, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.url',\n            });\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.request',\n            });\n        }\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            const matchResult = route.match({ url, request, event });\n            if (matchResult) {\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                params = matchResult;\n                if (Array.isArray(matchResult) && matchResult.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if ((matchResult.constructor === Object &&\n                    Object.keys(matchResult).length === 0)) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setDefaultHandler(handler) {\n        this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {module:workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {module:workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n"]},"metadata":{},"sourceType":"module"}