{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _toConsumableArray from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{cacheNames}from'workbox-core/_private/cacheNames.js';import{cacheWrapper}from'workbox-core/_private/cacheWrapper.js';import{fetchWrapper}from'workbox-core/_private/fetchWrapper.js';import{getFriendlyURL}from'workbox-core/_private/getFriendlyURL.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{messages}from\"./utils/messages.js\";import{cacheOkAndOpaquePlugin}from\"./plugins/cacheOkAndOpaquePlugin.js\";import\"./_version.js\";/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */var StaleWhileRevalidate=/*#__PURE__*/function(){/**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */function StaleWhileRevalidate(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,StaleWhileRevalidate);this._cacheName=cacheNames.getRuntimeName(options.cacheName);this._plugins=options.plugins||[];if(options.plugins){var isUsingCacheWillUpdate=options.plugins.some(function(plugin){return!!plugin.cacheWillUpdate;});this._plugins=isUsingCacheWillUpdate?options.plugins:[cacheOkAndOpaquePlugin].concat(_toConsumableArray(options.plugins));}else{// No plugins passed in, use the default plugin.\nthis._plugins=[cacheOkAndOpaquePlugin];}this._fetchOptions=options.fetchOptions;this._matchOptions=options.matchOptions;}/**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */_createClass(StaleWhileRevalidate,[{key:\"handle\",value:function(){var _handle=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var event,request,logs,fetchAndCachePromise,response,error,_iterator,_step,log;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:event=_ref.event,request=_ref.request;logs=[];if(typeof request==='string'){request=new Request(request);}if(process.env.NODE_ENV!=='production'){assert.isInstance(request,Request,{moduleName:'workbox-strategies',className:'StaleWhileRevalidate',funcName:'handle',paramName:'request'});}fetchAndCachePromise=this._getFromNetwork({request:request,event:event});_context.next=7;return cacheWrapper.match({cacheName:this._cacheName,request:request,event:event,matchOptions:this._matchOptions,plugins:this._plugins});case 7:response=_context.sent;if(!response){_context.next=13;break;}if(process.env.NODE_ENV!=='production'){logs.push(\"Found a cached response in the '\".concat(this._cacheName,\"'\")+\" cache. Will update with the network response in the background.\");}if(event){try{event.waitUntil(fetchAndCachePromise);}catch(error){if(process.env.NODE_ENV!=='production'){logger.warn(\"Unable to ensure service worker stays alive when \"+\"updating cache for '\".concat(getFriendlyURL(request.url),\"'.\"));}}}_context.next=23;break;case 13:if(process.env.NODE_ENV!=='production'){logs.push(\"No response found in the '\".concat(this._cacheName,\"' cache. \")+\"Will wait for the network response.\");}_context.prev=14;_context.next=17;return fetchAndCachePromise;case 17:response=_context.sent;_context.next=23;break;case 20:_context.prev=20;_context.t0=_context[\"catch\"](14);error=_context.t0;case 23:if(process.env.NODE_ENV!=='production'){logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate',request));_iterator=_createForOfIteratorHelper(logs);try{for(_iterator.s();!(_step=_iterator.n()).done;){log=_step.value;logger.log(log);}}catch(err){_iterator.e(err);}finally{_iterator.f();}messages.printFinalResponse(response);logger.groupEnd();}if(response){_context.next=26;break;}throw new WorkboxError('no-response',{url:request.url,error:error});case 26:return _context.abrupt(\"return\",response);case 27:case\"end\":return _context.stop();}}},_callee,this,[[14,20]]);}));function handle(_x){return _handle.apply(this,arguments);}return handle;}()/**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */},{key:\"_getFromNetwork\",value:function(){var _getFromNetwork2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2){var request,event,response,cachePutPromise;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:request=_ref2.request,event=_ref2.event;_context2.next=3;return fetchWrapper.fetch({request:request,event:event,fetchOptions:this._fetchOptions,plugins:this._plugins});case 3:response=_context2.sent;cachePutPromise=cacheWrapper.put({cacheName:this._cacheName,request:request,response:response.clone(),event:event,plugins:this._plugins});if(event){try{event.waitUntil(cachePutPromise);}catch(error){if(process.env.NODE_ENV!=='production'){logger.warn(\"Unable to ensure service worker stays alive when \"+\"updating cache for '\".concat(getFriendlyURL(request.url),\"'.\"));}}}return _context2.abrupt(\"return\",response);case 7:case\"end\":return _context2.stop();}}},_callee2,this);}));function _getFromNetwork(_x2){return _getFromNetwork2.apply(this,arguments);}return _getFromNetwork;}()}]);return StaleWhileRevalidate;}();export{StaleWhileRevalidate};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-strategies/StaleWhileRevalidate.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","getFriendlyURL","logger","WorkboxError","messages","cacheOkAndOpaquePlugin","StaleWhileRevalidate","options","_cacheName","getRuntimeName","cacheName","_plugins","plugins","isUsingCacheWillUpdate","some","plugin","cacheWillUpdate","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","logs","Request","process","env","NODE_ENV","isInstance","moduleName","className","funcName","paramName","fetchAndCachePromise","_getFromNetwork","match","response","push","waitUntil","error","warn","url","groupCollapsed","strategyStart","log","printFinalResponse","groupEnd","fetch","cachePutPromise","put","clone"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'StaleWhileRevalidate',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = this._getFromNetwork({ request, event });\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n            if (event) {\n                try {\n                    event.waitUntil(fetchAndCachePromise);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            }\n            catch (err) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork({ request, event }) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: response.clone(),\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"]},"metadata":{},"sourceType":"module"}