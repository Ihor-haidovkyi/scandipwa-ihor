{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{WorkboxError}from\"./WorkboxError.js\";import{logger}from\"./logger.js\";import{assert}from\"./assert.js\";import{getFriendlyURL}from\"../_private/getFriendlyURL.js\";import{pluginUtils}from\"../utils/pluginUtils.js\";import\"../_version.js\";/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */var wrappedFetch=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref){var request,fetchOptions,event,_ref$plugins,plugins,possiblePreloadResponse,failedFetchPlugins,originalRequest,_iterator,_step,plugin,pluginMethod,requestClone,pluginFilteredRequest,fetchResponse,_iterator2,_step2,_plugin,_iterator3,_step3,_plugin2;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:request=_ref.request,fetchOptions=_ref.fetchOptions,event=_ref.event,_ref$plugins=_ref.plugins,plugins=_ref$plugins===void 0?[]:_ref$plugins;if(typeof request==='string'){request=new Request(request);}// We *should* be able to call `await event.preloadResponse` even if it's\n// undefined, but for some reason, doing so leads to errors in our Node unit\n// tests. To work around that, explicitly check preloadResponse's value first.\nif(!(event instanceof FetchEvent&&event.preloadResponse)){_context.next=9;break;}_context.next=5;return event.preloadResponse;case 5:possiblePreloadResponse=_context.sent;if(!possiblePreloadResponse){_context.next=9;break;}if(process.env.NODE_ENV!=='production'){logger.log(\"Using a preloaded navigation response for \"+\"'\".concat(getFriendlyURL(request.url),\"'\"));}return _context.abrupt(\"return\",possiblePreloadResponse);case 9:if(process.env.NODE_ENV!=='production'){assert.isInstance(request,Request,{paramName:'request',expectedClass:Request,moduleName:'workbox-core',className:'fetchWrapper',funcName:'wrappedFetch'});}failedFetchPlugins=pluginUtils.filter(plugins,\"fetchDidFail\"/* FETCH_DID_FAIL */);// If there is a fetchDidFail plugin, we need to save a clone of the\n// original request before it's either modified by a requestWillFetch\n// plugin or before the original request's body is consumed via fetch().\noriginalRequest=failedFetchPlugins.length>0?request.clone():null;_context.prev=12;_iterator=_createForOfIteratorHelper(plugins);_context.prev=14;_iterator.s();case 16:if((_step=_iterator.n()).done){_context.next=27;break;}plugin=_step.value;if(!(\"requestWillFetch\"/* REQUEST_WILL_FETCH */in plugin)){_context.next=25;break;}pluginMethod=plugin[\"requestWillFetch\"/* REQUEST_WILL_FETCH */];requestClone=request.clone();_context.next=23;return pluginMethod.call(plugin,{request:requestClone,event:event});case 23:request=_context.sent;if(process.env.NODE_ENV!=='production'){if(request){assert.isInstance(request,Request,{moduleName:'Plugin',funcName:\"cachedResponseWillBeUsed\"/* CACHED_RESPONSE_WILL_BE_USED */,isReturnValueProblem:true});}}case 25:_context.next=16;break;case 27:_context.next=32;break;case 29:_context.prev=29;_context.t0=_context[\"catch\"](14);_iterator.e(_context.t0);case 32:_context.prev=32;_iterator.f();return _context.finish(32);case 35:_context.next=40;break;case 37:_context.prev=37;_context.t1=_context[\"catch\"](12);throw new WorkboxError('plugin-error-request-will-fetch',{thrownError:_context.t1});case 40:// The request can be altered by plugins with `requestWillFetch` making\n// the original request (Most likely from a `fetch` event) to be different\n// to the Request we make. Pass both to `fetchDidFail` to aid debugging.\npluginFilteredRequest=request.clone();_context.prev=41;if(!(request.mode==='navigate')){_context.next=48;break;}_context.next=45;return fetch(request);case 45:fetchResponse=_context.sent;_context.next=51;break;case 48:_context.next=50;return fetch(request,fetchOptions);case 50:fetchResponse=_context.sent;case 51:if(process.env.NODE_ENV!=='production'){logger.debug(\"Network request for \"+\"'\".concat(getFriendlyURL(request.url),\"' returned a response with \")+\"status '\".concat(fetchResponse.status,\"'.\"));}_iterator2=_createForOfIteratorHelper(plugins);_context.prev=53;_iterator2.s();case 55:if((_step2=_iterator2.n()).done){_context.next=64;break;}_plugin=_step2.value;if(!(\"fetchDidSucceed\"/* FETCH_DID_SUCCEED */in _plugin)){_context.next=62;break;}_context.next=60;return _plugin[\"fetchDidSucceed\"/* FETCH_DID_SUCCEED */].call(_plugin,{event:event,request:pluginFilteredRequest,response:fetchResponse});case 60:fetchResponse=_context.sent;if(process.env.NODE_ENV!=='production'){if(fetchResponse){assert.isInstance(fetchResponse,Response,{moduleName:'Plugin',funcName:\"fetchDidSucceed\"/* FETCH_DID_SUCCEED */,isReturnValueProblem:true});}}case 62:_context.next=55;break;case 64:_context.next=69;break;case 66:_context.prev=66;_context.t2=_context[\"catch\"](53);_iterator2.e(_context.t2);case 69:_context.prev=69;_iterator2.f();return _context.finish(69);case 72:return _context.abrupt(\"return\",fetchResponse);case 75:_context.prev=75;_context.t3=_context[\"catch\"](41);if(process.env.NODE_ENV!=='production'){logger.error(\"Network request for \"+\"'\".concat(getFriendlyURL(request.url),\"' threw an error.\"),_context.t3);}_iterator3=_createForOfIteratorHelper(failedFetchPlugins);_context.prev=79;_iterator3.s();case 81:if((_step3=_iterator3.n()).done){_context.next=87;break;}_plugin2=_step3.value;_context.next=85;return _plugin2[\"fetchDidFail\"/* FETCH_DID_FAIL */].call(_plugin2,{error:_context.t3,event:event,originalRequest:originalRequest.clone(),request:pluginFilteredRequest.clone()});case 85:_context.next=81;break;case 87:_context.next=92;break;case 89:_context.prev=89;_context.t4=_context[\"catch\"](79);_iterator3.e(_context.t4);case 92:_context.prev=92;_iterator3.f();return _context.finish(92);case 95:throw _context.t3;case 96:case\"end\":return _context.stop();}}},_callee,null,[[12,37],[14,29,32,35],[41,75],[53,66,69,72],[79,89,92,95]]);}));return function wrappedFetch(_x){return _ref2.apply(this,arguments);};}();var fetchWrapper={fetch:wrappedFetch};export{fetchWrapper};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-core/_private/fetchWrapper.js"],"names":["WorkboxError","logger","assert","getFriendlyURL","pluginUtils","wrappedFetch","request","fetchOptions","event","plugins","Request","FetchEvent","preloadResponse","possiblePreloadResponse","process","env","NODE_ENV","log","url","isInstance","paramName","expectedClass","moduleName","className","funcName","failedFetchPlugins","filter","originalRequest","length","clone","plugin","pluginMethod","requestClone","call","isReturnValueProblem","thrownError","pluginFilteredRequest","mode","fetch","fetchResponse","debug","status","response","Response","error","fetchWrapper"],"mappings":"wcAAA;AACA;AACA;AACA;AACA;AACA;AACA,EACA,OAASA,YAAT,yBACA,OAASC,MAAT,mBACA,OAASC,MAAT,mBACA,OAASC,cAAT,qCACA,OAASC,WAAT,+BACA,uBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,GAAMC,CAAAA,YAAY,2FAAG,gYAASC,OAAT,MAASA,OAAT,CAAkBC,YAAlB,MAAkBA,YAAlB,CAAgCC,KAAhC,MAAgCA,KAAhC,mBAAuCC,OAAvC,CAAuCA,OAAvC,uBAAiD,EAAjD,cACjB,GAAI,MAAOH,CAAAA,OAAP,GAAmB,QAAvB,CAAiC,CAC7BA,OAAO,CAAG,GAAII,CAAAA,OAAJ,CAAYJ,OAAZ,CAAV,CACH,CACD;AACA;AACA;AANiB,KAObE,KAAK,WAAYG,CAAAA,UAAjB,EAA+BH,KAAK,CAACI,eAPxB,gDAQyBJ,CAAAA,KAAK,CAACI,eAR/B,QAQPC,uBARO,mBASTA,uBATS,yBAUT,GAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCf,MAAM,CAACgB,GAAP,CAAW,wDACHd,cAAc,CAACG,OAAO,CAACY,GAAT,CADX,KAAX,EAEH,CAbQ,gCAcFL,uBAdE,SAiBjB,GAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCd,MAAM,CAACiB,UAAP,CAAkBb,OAAlB,CAA2BI,OAA3B,CAAoC,CAChCU,SAAS,CAAE,SADqB,CAEhCC,aAAa,CAAEX,OAFiB,CAGhCY,UAAU,CAAE,cAHoB,CAIhCC,SAAS,CAAE,cAJqB,CAKhCC,QAAQ,CAAE,cALsB,CAApC,EAOH,CACKC,kBA1BW,CA0BUrB,WAAW,CAACsB,MAAZ,CAAmBjB,OAAnB,CAA4B,cAAe,oBAA3C,CA1BV,CA2BjB;AACA;AACA;AACMkB,eA9BW,CA8BOF,kBAAkB,CAACG,MAAnB,CAA4B,CAA5B,CACpBtB,OAAO,CAACuB,KAAR,EADoB,CACF,IA/BL,uDAiCQpB,OAjCR,gGAiCFqB,MAjCE,kBAkCL,kBAAmB,wBAAnB,EAA+CA,CAAAA,MAlC1C,2BAmCCC,YAnCD,CAmCgBD,MAAM,CAAC,kBAAmB,wBAApB,CAnCtB,CAoCCE,YApCD,CAoCgB1B,OAAO,CAACuB,KAAR,EApChB,wBAqCWE,CAAAA,YAAY,CAACE,IAAb,CAAkBH,MAAlB,CAA0B,CACtCxB,OAAO,CAAE0B,YAD6B,CAEtCxB,KAAK,CAALA,KAFsC,CAA1B,CArCX,SAqCLF,OArCK,eAyCL,GAAIQ,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC,GAAIV,OAAJ,CAAa,CACTJ,MAAM,CAACiB,UAAP,CAAkBb,OAAlB,CAA2BI,OAA3B,CAAoC,CAChCY,UAAU,CAAE,QADoB,CAEhCE,QAAQ,CAAE,0BAA2B,kCAFL,CAGhCU,oBAAoB,CAAE,IAHU,CAApC,EAKH,CACJ,CAjDI,mTAsDP,IAAIlC,CAAAA,YAAJ,CAAiB,iCAAjB,CAAoD,CACtDmC,WAAW,YAD2C,CAApD,CAtDO,SA0DjB;AACA;AACA;AACMC,qBA7DW,CA6Da9B,OAAO,CAACuB,KAAR,EA7Db,uBAiETvB,OAAO,CAAC+B,IAAR,GAAiB,UAjER,kDAkEaC,CAAAA,KAAK,CAAChC,OAAD,CAlElB,SAkETiC,aAlES,qEAqEaD,CAAAA,KAAK,CAAChC,OAAD,CAAUC,YAAV,CArElB,SAqETgC,aArES,uBAuEb,GAAIzB,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCf,MAAM,CAACuC,KAAP,CAAa,kCACLrC,cAAc,CAACG,OAAO,CAACY,GAAT,CADT,kDAEEqB,aAAa,CAACE,MAFhB,MAAb,EAGH,CA3EY,sCA4EQhC,OA5ER,mGA4EFqB,OA5EE,mBA6EL,iBAAkB,uBAAlB,EAA6CA,CAAAA,OA7ExC,kDA8EiBA,CAAAA,OAAM,CAAC,iBAAkB,uBAAnB,CAAN,CACjBG,IADiB,CACZH,OADY,CACJ,CACdtB,KAAK,CAALA,KADc,CAEdF,OAAO,CAAE8B,qBAFK,CAGdM,QAAQ,CAAEH,aAHI,CADI,CA9EjB,SA8ELA,aA9EK,eAoFL,GAAIzB,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvC,GAAIuB,aAAJ,CAAmB,CACfrC,MAAM,CAACiB,UAAP,CAAkBoB,aAAlB,CAAiCI,QAAjC,CAA2C,CACvCrB,UAAU,CAAE,QAD2B,CAEvCE,QAAQ,CAAE,iBAAkB,uBAFW,CAGvCU,oBAAoB,CAAE,IAHiB,CAA3C,EAKH,CACJ,CA5FI,8PA+FNK,aA/FM,6DAkGb,GAAIzB,OAAO,CAACC,GAAR,CAAYC,QAAZ,GAAyB,YAA7B,CAA2C,CACvCf,MAAM,CAAC2C,KAAP,CAAa,kCACLzC,cAAc,CAACG,OAAO,CAACY,GAAT,CADT,qBAAb,cAEH,CArGY,sCAsGQO,kBAtGR,mGAsGFK,QAtGE,qCAuGHA,CAAAA,QAAM,CAAC,cAAe,oBAAhB,CAAN,CAA4CG,IAA5C,CAAiDH,QAAjD,CAAyD,CAC3Dc,KAAK,YADsD,CAE3DpC,KAAK,CAALA,KAF2D,CAG3DmB,eAAe,CAAEA,eAAe,CAACE,KAAhB,EAH0C,CAI3DvB,OAAO,CAAE8B,qBAAqB,CAACP,KAAtB,EAJkD,CAAzD,CAvGG,yWAAH,kBAAZxB,CAAAA,YAAY,6CAAlB,CAiHA,GAAMwC,CAAAA,YAAY,CAAG,CACjBP,KAAK,CAAEjC,YADU,CAArB,CAGA,OAASwC,YAAT","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({ request, fetchOptions, event, plugins = [], }) => {\n    if (typeof request === 'string') {\n        request = new Request(request);\n    }\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n        if (possiblePreloadResponse) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Using a preloaded navigation response for ` +\n                    `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n            paramName: 'request',\n            expectedClass: Request,\n            moduleName: 'workbox-core',\n            className: 'fetchWrapper',\n            funcName: 'wrappedFetch',\n        });\n    }\n    const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */);\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = failedFetchPlugins.length > 0 ?\n        request.clone() : null;\n    try {\n        for (const plugin of plugins) {\n            if (\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin) {\n                const pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n                const requestClone = request.clone();\n                request = await pluginMethod.call(plugin, {\n                    request: requestClone,\n                    event,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (request) {\n                        assert.isInstance(request, Request, {\n                            moduleName: 'Plugin',\n                            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: err,\n        });\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n        let fetchResponse;\n        // See https://github.com/GoogleChrome/workbox/issues/1796\n        if (request.mode === 'navigate') {\n            fetchResponse = await fetch(request);\n        }\n        else {\n            fetchResponse = await fetch(request, fetchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' returned a response with ` +\n                `status '${fetchResponse.status}'.`);\n        }\n        for (const plugin of plugins) {\n            if (\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in plugin) {\n                fetchResponse = await plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */]\n                    .call(plugin, {\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (fetchResponse) {\n                        assert.isInstance(fetchResponse, Response, {\n                            moduleName: 'Plugin',\n                            funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n        return fetchResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n        for (const plugin of failedFetchPlugins) {\n            await plugin[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(plugin, {\n                error,\n                event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone(),\n            });\n        }\n        throw error;\n    }\n};\nconst fetchWrapper = {\n    fetch: wrappedFetch,\n};\nexport { fetchWrapper };\n"]},"metadata":{},"sourceType":"module"}