{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{Route}from\"./Route.js\";import{RegExpRoute}from\"./RegExpRoute.js\";import{getOrCreateDefaultRouter}from\"./utils/getOrCreateDefaultRouter.js\";import\"./_version.js\";/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {module:workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {module:workbox-routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @memberof module:workbox-routing\n */function registerRoute(capture,handler,method){var route;if(typeof capture==='string'){var captureUrl=new URL(capture,location.href);if(process.env.NODE_ENV!=='production'){if(!(capture.startsWith('/')||capture.startsWith('http'))){throw new WorkboxError('invalid-string',{moduleName:'workbox-routing',funcName:'registerRoute',paramName:'capture'});}// We want to check if Express-style wildcards are in the pathname only.\n// TODO: Remove this log message in v4.\nvar valueToCheck=capture.startsWith('http')?captureUrl.pathname:capture;// See https://github.com/pillarjs/path-to-regexp#parameters\nvar wildcards='[*:?+]';if(new RegExp(\"\".concat(wildcards)).exec(valueToCheck)){logger.debug(\"The '$capture' parameter contains an Express-style wildcard \"+\"character (\".concat(wildcards,\"). Strings are now always interpreted as \")+\"exact matches; use a RegExp for partial or wildcard matches.\");}}var matchCallback=function matchCallback(_ref){var url=_ref.url;if(process.env.NODE_ENV!=='production'){if(url.pathname===captureUrl.pathname&&url.origin!==captureUrl.origin){logger.debug(\"\".concat(capture,\" only partially matches the cross-origin URL \")+\"\".concat(url,\". This route will only handle cross-origin requests \")+\"if they match the entire URL.\");}}return url.href===captureUrl.href;};// If `capture` is a string then `handler` and `method` must be present.\nroute=new Route(matchCallback,handler,method);}else if(capture instanceof RegExp){// If `capture` is a `RegExp` then `handler` and `method` must be present.\nroute=new RegExpRoute(capture,handler,method);}else if(typeof capture==='function'){// If `capture` is a function then `handler` and `method` must be present.\nroute=new Route(capture,handler,method);}else if(capture instanceof Route){route=capture;}else{throw new WorkboxError('unsupported-route-type',{moduleName:'workbox-routing',funcName:'registerRoute',paramName:'capture'});}var defaultRouter=getOrCreateDefaultRouter();defaultRouter.registerRoute(route);return route;}export{registerRoute};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-routing/registerRoute.js"],"names":["logger","WorkboxError","Route","RegExpRoute","getOrCreateDefaultRouter","registerRoute","capture","handler","method","route","captureUrl","URL","location","href","process","env","NODE_ENV","startsWith","moduleName","funcName","paramName","valueToCheck","pathname","wildcards","RegExp","exec","debug","matchCallback","url","origin","defaultRouter"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {module:workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {module:workbox-routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @memberof module:workbox-routing\n */\nfunction registerRoute(capture, handler, method) {\n    let route;\n    if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n                throw new WorkboxError('invalid-string', {\n                    moduleName: 'workbox-routing',\n                    funcName: 'registerRoute',\n                    paramName: 'capture',\n                });\n            }\n            // We want to check if Express-style wildcards are in the pathname only.\n            // TODO: Remove this log message in v4.\n            const valueToCheck = capture.startsWith('http') ?\n                captureUrl.pathname : capture;\n            // See https://github.com/pillarjs/path-to-regexp#parameters\n            const wildcards = '[*:?+]';\n            if ((new RegExp(`${wildcards}`)).exec(valueToCheck)) {\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +\n                    `character (${wildcards}). Strings are now always interpreted as ` +\n                    `exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((url.pathname === captureUrl.pathname) &&\n                    (url.origin !== captureUrl.origin)) {\n                    logger.debug(`${capture} only partially matches the cross-origin URL ` +\n                        `${url}. This route will only handle cross-origin requests ` +\n                        `if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n    }\n    else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n    }\n    else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n    }\n    else if (capture instanceof Route) {\n        route = capture;\n    }\n    else {\n        throw new WorkboxError('unsupported-route-type', {\n            moduleName: 'workbox-routing',\n            funcName: 'registerRoute',\n            paramName: 'capture',\n        });\n    }\n    const defaultRouter = getOrCreateDefaultRouter();\n    defaultRouter.registerRoute(route);\n    return route;\n}\nexport { registerRoute };\n"]},"metadata":{},"sourceType":"module"}