{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{timeout}from\"./timeout.js\";import\"../_version.js\";var MAX_RETRY_TIME=2000;/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */export function resultingClientExists(_x){return _resultingClientExists.apply(this,arguments);}function _resultingClientExists(){_resultingClientExists=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(resultingClientId){var existingWindows,existingWindowIds,resultingWindow,startTime;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(resultingClientId){_context.next=2;break;}return _context.abrupt(\"return\");case 2:_context.next=4;return self.clients.matchAll({type:'window'});case 4:existingWindows=_context.sent;existingWindowIds=new Set(existingWindows.map(function(w){return w.id;}));startTime=performance.now();// Only wait up to `MAX_RETRY_TIME` to find a matching client.\ncase 7:if(!(performance.now()-startTime<MAX_RETRY_TIME)){_context.next=18;break;}_context.next=10;return self.clients.matchAll({type:'window'});case 10:existingWindows=_context.sent;resultingWindow=existingWindows.find(function(w){if(resultingClientId){// If we have a `resultingClientId`, we can match on that.\nreturn w.id===resultingClientId;}else{// Otherwise match on finding a window not in `existingWindowIds`.\nreturn!existingWindowIds.has(w.id);}});if(!resultingWindow){_context.next=14;break;}return _context.abrupt(\"break\",18);case 14:_context.next=16;return timeout(100);case 16:_context.next=7;break;case 18:return _context.abrupt(\"return\",resultingWindow);case 19:case\"end\":return _context.stop();}}},_callee);}));return _resultingClientExists.apply(this,arguments);}","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-core/_private/resultingClientExists.js"],"names":["timeout","MAX_RETRY_TIME","resultingClientExists","resultingClientId","self","clients","matchAll","type","existingWindows","existingWindowIds","Set","map","w","id","startTime","performance","now","resultingWindow","find","has"],"mappings":"+RAAA;AACA;AACA;AACA;AACA;AACA,EACA,OAASA,OAAT,oBACA,uBACA,GAAMC,CAAAA,cAAc,CAAG,IAAvB,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,eAAsBC,CAAAA,qBAAtB,0D,iHAAO,iBAAqCC,iBAArC,qLACEA,iBADF,uFAIyBC,CAAAA,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB,CAAEC,IAAI,CAAE,QAAR,CAAtB,CAJzB,QAICC,eAJD,eAKGC,iBALH,CAKuB,GAAIC,CAAAA,GAAJ,CAAQF,eAAe,CAACG,GAAhB,CAAoB,SAACC,CAAD,QAAOA,CAAAA,CAAC,CAACC,EAAT,EAApB,CAAR,CALvB,CAOGC,SAPH,CAOeC,WAAW,CAACC,GAAZ,EAPf,CAQH;AARG,YASID,WAAW,CAACC,GAAZ,GAAoBF,SAApB,CAAgCb,cATpC,kDAUyBG,CAAAA,IAAI,CAACC,OAAL,CAAaC,QAAb,CAAsB,CAAEC,IAAI,CAAE,QAAR,CAAtB,CAVzB,SAUCC,eAVD,eAWCS,eAAe,CAAGT,eAAe,CAACU,IAAhB,CAAqB,SAACN,CAAD,CAAO,CAC1C,GAAIT,iBAAJ,CAAuB,CACnB;AACA,MAAOS,CAAAA,CAAC,CAACC,EAAF,GAASV,iBAAhB,CACH,CAHD,IAIK,CACD;AACA,MAAO,CAACM,iBAAiB,CAACU,GAAlB,CAAsBP,CAAC,CAACC,EAAxB,CAAR,CACH,CACJ,CATiB,CAAlB,CAXD,IAqBKI,eArBL,4FAyBOjB,CAAAA,OAAO,CAAC,GAAD,CAzBd,uEA2BIiB,eA3BJ,yD","sourcesContent":["/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nconst MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\nexport async function resultingClientExists(resultingClientId) {\n    if (!resultingClientId) {\n        return;\n    }\n    let existingWindows = await self.clients.matchAll({ type: 'window' });\n    const existingWindowIds = new Set(existingWindows.map((w) => w.id));\n    let resultingWindow;\n    const startTime = performance.now();\n    // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n    while (performance.now() - startTime < MAX_RETRY_TIME) {\n        existingWindows = await self.clients.matchAll({ type: 'window' });\n        resultingWindow = existingWindows.find((w) => {\n            if (resultingClientId) {\n                // If we have a `resultingClientId`, we can match on that.\n                return w.id === resultingClientId;\n            }\n            else {\n                // Otherwise match on finding a window not in `existingWindowIds`.\n                return !existingWindowIds.has(w.id);\n            }\n        });\n        if (resultingWindow) {\n            break;\n        }\n        // Sleep for 100ms and retry.\n        await timeout(100);\n    }\n    return resultingWindow;\n}\n"]},"metadata":{},"sourceType":"module"}