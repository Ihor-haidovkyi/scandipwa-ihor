{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/* eslint-disable @scandipwa/scandipwa-guidelines/export-level-one */ /**\n * ScandiPWA - Progressive Web App for Magento\n *\n * Copyright © Scandiweb, Inc. All rights reserved.\n * See LICENSE for license details.\n *\n * @license OSL-3.0 (Open Software License (\"OSL\") v. 3.0)\n * @package scandipwa/base-theme\n * @link https://github.com/scandipwa/base-theme\n */import{clientsClaim}from'workbox-core';import{ExpirationPlugin}from'workbox-expiration';import{precacheAndRoute}from'workbox-precaching';import{registerRoute}from'workbox-routing';import{StaleWhileRevalidate}from'workbox-strategies';clientsClaim();// Precache all of the assets generated by your build process.\n// Their URLs are injected into the manifest variable below.\n// This variable must be present somewhere in your service worker file,\n// even if you decide not to use precaching. See https://cra.link/PWA\nprecacheAndRoute(self.__WB_MANIFEST);// Cache same-origin image requests\nregisterRoute(function(_ref){var url=_ref.url;return url.origin===self.location.origin// cache png, gif, jpeg, jpg in image cache\n&&/.(jpe?g|png|gif)$/.test(url.pathname);},new StaleWhileRevalidate({cacheName:'images',plugins:[// Ensure that once this runtime cache reaches a maximum size the\n// least-recently used images are removed.\nnew ExpirationPlugin({maxEntries:50})]}));// This allows the web app to trigger skipWaiting via\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\nself.addEventListener('message',function(event){if(event.data&&event.data.type==='SKIP_WAITING'){self.skipWaiting();}});var RESPONSE_OK=200;var makeRequestAndUpdateCache=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(request,cache){var response,isValid;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return fetch(request);case 2:response=_context.sent;isValid=response.status===RESPONSE_OK;if(isValid){cache.put(request.url,response.clone());}return _context.abrupt(\"return\",response);case 6:case\"end\":return _context.stop();}}},_callee);}));return function makeRequestAndUpdateCache(_x,_x2){return _ref2.apply(this,arguments);};}();var updateWithFreshDataViaBroadcast=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(request,cache){var type,revalidatedResponse,responseClone,broadcast;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:type=request.headers.get('Application-Model');_context2.next=3;return makeRequestAndUpdateCache(request,cache);case 3:revalidatedResponse=_context2.sent;responseClone=revalidatedResponse.clone();broadcast=new BroadcastChannel(type);_context2.t0=broadcast;_context2.next=9;return responseClone.json();case 9:_context2.t1=_context2.sent;_context2.t2=type;_context2.t3={payload:_context2.t1,type:_context2.t2};_context2.t0.postMessage.call(_context2.t0,_context2.t3);broadcast.close();case 14:case\"end\":return _context2.stop();}}},_callee2);}));return function updateWithFreshDataViaBroadcast(_x3,_x4){return _ref3.apply(this,arguments);};}();registerRoute(/\\/graphql/,/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4){var event,request,cache,cachedResponse;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:event=_ref4.event;request=event.request;_context3.next=4;return caches.open('graphql');case 4:cache=_context3.sent;_context3.next=7;return cache.match(request);case 7:cachedResponse=_context3.sent;if(cachedResponse){_context3.next=10;break;}return _context3.abrupt(\"return\",makeRequestAndUpdateCache(request,cache));case 10:// For cached response, still do the request, but in background.\n// We will use the BroadCast channel to update the client if the data is new\nupdateWithFreshDataViaBroadcast(request,cache);return _context3.abrupt(\"return\",cachedResponse);case 12:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x5){return _ref5.apply(this,arguments);};}());// respond to document request only in offline\nregisterRoute(function(_ref6){var request=_ref6.request;var url=request.url,destination=request.destination;var _URL=new URL(url),hostname=_URL.hostname;if(destination!=='document'){// skip all NON documents\nreturn false;}if(hostname!==self.location.hostname){// skip requests to other domains\nreturn false;}return true;},/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref7){var event,request,cache,responseFromCache,rootResponse;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:event=_ref7.event;request=event.request;_context4.next=4;return caches.open(self.CACHE_NAME);case 4:cache=_context4.sent;_context4.next=7;return cache.match('/');case 7:responseFromCache=_context4.sent;if(navigator.onLine){_context4.next=10;break;}return _context4.abrupt(\"return\",responseFromCache);case 10:if(responseFromCache){_context4.next=15;break;}_context4.next=13;return fetch('/');case 13:rootResponse=_context4.sent;if(rootResponse.status===RESPONSE_OK){// Cache only 200 responses, to make sure, that when we are\n// offline the page will still load as normal.\ncache.put('/',rootResponse.clone());}case 15:return _context4.abrupt(\"return\",fetch(request));case 16:case\"end\":return _context4.stop();}}},_callee4);}));return function(_x6){return _ref8.apply(this,arguments);};}());","map":{"version":3,"sources":["/home/marketihor/scandipwa/packages/scandipwa/src/service-worker.js"],"names":["clientsClaim","ExpirationPlugin","precacheAndRoute","registerRoute","StaleWhileRevalidate","self","__WB_MANIFEST","url","origin","location","test","pathname","cacheName","plugins","maxEntries","addEventListener","event","data","type","skipWaiting","RESPONSE_OK","makeRequestAndUpdateCache","request","cache","fetch","response","isValid","status","put","clone","updateWithFreshDataViaBroadcast","headers","get","revalidatedResponse","responseClone","broadcast","BroadcastChannel","json","payload","postMessage","close","caches","open","match","cachedResponse","destination","URL","hostname","CACHE_NAME","responseFromCache","navigator","onLine","rootResponse"],"mappings":"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","sourcesContent":["/* eslint-disable @scandipwa/scandipwa-guidelines/export-level-one */\n\n/**\n * ScandiPWA - Progressive Web App for Magento\n *\n * Copyright © Scandiweb, Inc. All rights reserved.\n * See LICENSE for license details.\n *\n * @license OSL-3.0 (Open Software License (\"OSL\") v. 3.0)\n * @package scandipwa/base-theme\n * @link https://github.com/scandipwa/base-theme\n */\n\nimport { clientsClaim } from 'workbox-core';\nimport { ExpirationPlugin } from 'workbox-expiration';\nimport { precacheAndRoute } from 'workbox-precaching';\nimport { registerRoute } from 'workbox-routing';\nimport { StaleWhileRevalidate } from 'workbox-strategies';\n\nclientsClaim();\n\n// Precache all of the assets generated by your build process.\n// Their URLs are injected into the manifest variable below.\n// This variable must be present somewhere in your service worker file,\n// even if you decide not to use precaching. See https://cra.link/PWA\nprecacheAndRoute(self.__WB_MANIFEST);\n\n// Cache same-origin image requests\nregisterRoute(\n    ({ url }) => (\n        url.origin === self.location.origin\n        // cache png, gif, jpeg, jpg in image cache\n        && /.(jpe?g|png|gif)$/.test(url.pathname)\n    ),\n    new StaleWhileRevalidate({\n        cacheName: 'images',\n        plugins: [\n            // Ensure that once this runtime cache reaches a maximum size the\n            // least-recently used images are removed.\n            new ExpirationPlugin({ maxEntries: 50 })\n        ]\n    })\n);\n\n// This allows the web app to trigger skipWaiting via\n// registration.waiting.postMessage({type: 'SKIP_WAITING'})\nself.addEventListener('message', (event) => {\n    if (event.data && event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    }\n});\n\nconst RESPONSE_OK = 200;\n\nconst makeRequestAndUpdateCache = async (request, cache) => {\n    const response = await fetch(request);\n    const isValid = response.status === RESPONSE_OK;\n\n    if (isValid) {\n        cache.put(request.url, response.clone());\n    }\n\n    return response;\n};\n\nconst updateWithFreshDataViaBroadcast = async (request, cache) => {\n    const type = request.headers.get('Application-Model');\n    const revalidatedResponse = await makeRequestAndUpdateCache(request, cache);\n    const responseClone = revalidatedResponse.clone();\n    const broadcast = new BroadcastChannel(type);\n    broadcast.postMessage({ payload: await responseClone.json(), type });\n    broadcast.close();\n};\n\nregisterRoute(\n    /\\/graphql/,\n    async ({ event }) => {\n        const { request } = event;\n        const cache = await caches.open('graphql');\n        const cachedResponse = await cache.match(request);\n\n        if (!cachedResponse) {\n            // If there is no cached response,\n            // we must get the response and save it to cache!\n            return makeRequestAndUpdateCache(request, cache);\n        }\n\n        // For cached response, still do the request, but in background.\n        // We will use the BroadCast channel to update the client if the data is new\n        updateWithFreshDataViaBroadcast(request, cache);\n\n        return cachedResponse;\n    }\n);\n\n// respond to document request only in offline\nregisterRoute(\n    ({ request }) => {\n        const { url, destination } = request;\n        const { hostname } = new URL(url);\n\n        if (destination !== 'document') {\n            // skip all NON documents\n            return false;\n        }\n\n        if (hostname !== self.location.hostname) {\n            // skip requests to other domains\n            return false;\n        }\n\n        return true;\n    },\n    async ({ event }) => {\n        const { request } = event;\n\n        const cache = await caches.open(self.CACHE_NAME);\n        const responseFromCache = await cache.match('/');\n\n        if (!navigator.onLine) {\n            // Always respond from cache if we are offline\n            return responseFromCache;\n        }\n\n        if (!responseFromCache) {\n            // Respond from server\n            const rootResponse = await fetch('/');\n\n            if (rootResponse.status === RESPONSE_OK) {\n                // Cache only 200 responses, to make sure, that when we are\n                // offline the page will still load as normal.\n                cache.put('/', rootResponse.clone());\n            }\n        }\n\n        return fetch(request); // respond from server\n    }\n);\n"]},"metadata":{},"sourceType":"module"}