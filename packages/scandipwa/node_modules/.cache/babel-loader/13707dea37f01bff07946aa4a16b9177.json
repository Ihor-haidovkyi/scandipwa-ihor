{"ast":null,"code":"import _regeneratorRuntime from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _createForOfIteratorHelper from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _asyncToGenerator from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/marketihor/scandipwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/import{assert}from'workbox-core/_private/assert.js';import{dontWaitFor}from'workbox-core/_private/dontWaitFor.js';import{logger}from'workbox-core/_private/logger.js';import{WorkboxError}from'workbox-core/_private/WorkboxError.js';import{CacheTimestampsModel}from\"./models/CacheTimestampsModel.js\";import\"./_version.js\";/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */var CacheExpiration=/*#__PURE__*/function(){/**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */function CacheExpiration(cacheName){var config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,CacheExpiration);this._isRunning=false;this._rerunRequested=false;if(process.env.NODE_ENV!=='production'){assert.isType(cacheName,'string',{moduleName:'workbox-expiration',className:'CacheExpiration',funcName:'constructor',paramName:'cacheName'});if(!(config.maxEntries||config.maxAgeSeconds)){throw new WorkboxError('max-entries-or-age-required',{moduleName:'workbox-expiration',className:'CacheExpiration',funcName:'constructor'});}if(config.maxEntries){assert.isType(config.maxEntries,'number',{moduleName:'workbox-expiration',className:'CacheExpiration',funcName:'constructor',paramName:'config.maxEntries'});// TODO: Assert is positive\n}if(config.maxAgeSeconds){assert.isType(config.maxAgeSeconds,'number',{moduleName:'workbox-expiration',className:'CacheExpiration',funcName:'constructor',paramName:'config.maxAgeSeconds'});// TODO: Assert is positive\n}}this._maxEntries=config.maxEntries;this._maxAgeSeconds=config.maxAgeSeconds;this._cacheName=cacheName;this._timestampModel=new CacheTimestampsModel(cacheName);}/**\n     * Expires entries for the given cache and given criteria.\n     */_createClass(CacheExpiration,[{key:\"expireEntries\",value:function(){var _expireEntries=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var minTimestamp,urlsExpired,cache,_iterator,_step,url;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!this._isRunning){_context.next=3;break;}this._rerunRequested=true;return _context.abrupt(\"return\");case 3:this._isRunning=true;minTimestamp=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1000:0;_context.next=7;return this._timestampModel.expireEntries(minTimestamp,this._maxEntries);case 7:urlsExpired=_context.sent;_context.next=10;return self.caches.open(this._cacheName);case 10:cache=_context.sent;_iterator=_createForOfIteratorHelper(urlsExpired);_context.prev=12;_iterator.s();case 14:if((_step=_iterator.n()).done){_context.next=20;break;}url=_step.value;_context.next=18;return cache.delete(url);case 18:_context.next=14;break;case 20:_context.next=25;break;case 22:_context.prev=22;_context.t0=_context[\"catch\"](12);_iterator.e(_context.t0);case 25:_context.prev=25;_iterator.f();return _context.finish(25);case 28:if(process.env.NODE_ENV!=='production'){if(urlsExpired.length>0){logger.groupCollapsed(\"Expired \".concat(urlsExpired.length,\" \")+\"\".concat(urlsExpired.length===1?'entry':'entries',\" and removed \")+\"\".concat(urlsExpired.length===1?'it':'them',\" from the \")+\"'\".concat(this._cacheName,\"' cache.\"));logger.log(\"Expired the following \".concat(urlsExpired.length===1?'URL':'URLs',\":\"));urlsExpired.forEach(function(url){return logger.log(\"    \".concat(url));});logger.groupEnd();}else{logger.debug(\"Cache expiration ran and found no entries to remove.\");}}this._isRunning=false;if(this._rerunRequested){this._rerunRequested=false;dontWaitFor(this.expireEntries());}case 31:case\"end\":return _context.stop();}}},_callee,this,[[12,22,25,28]]);}));function expireEntries(){return _expireEntries.apply(this,arguments);}return expireEntries;}()/**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */},{key:\"updateTimestamp\",value:function(){var _updateTimestamp=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url){return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(process.env.NODE_ENV!=='production'){assert.isType(url,'string',{moduleName:'workbox-expiration',className:'CacheExpiration',funcName:'updateTimestamp',paramName:'url'});}_context2.next=3;return this._timestampModel.setTimestamp(url,Date.now());case 3:case\"end\":return _context2.stop();}}},_callee2,this);}));function updateTimestamp(_x){return _updateTimestamp.apply(this,arguments);}return updateTimestamp;}()/**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */},{key:\"isURLExpired\",value:function(){var _isURLExpired=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(url){var timestamp,expireOlderThan;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(this._maxAgeSeconds){_context3.next=6;break;}if(!(process.env.NODE_ENV!=='production')){_context3.next=3;break;}throw new WorkboxError(\"expired-test-without-max-age\",{methodName:'isURLExpired',paramName:'maxAgeSeconds'});case 3:return _context3.abrupt(\"return\",false);case 6:_context3.next=8;return this._timestampModel.getTimestamp(url);case 8:timestamp=_context3.sent;expireOlderThan=Date.now()-this._maxAgeSeconds*1000;return _context3.abrupt(\"return\",timestamp<expireOlderThan);case 11:case\"end\":return _context3.stop();}}},_callee3,this);}));function isURLExpired(_x2){return _isURLExpired.apply(this,arguments);}return isURLExpired;}()/**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */},{key:\"delete\",value:function(){var _delete2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(){return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:// Make sure we don't attempt another rerun if we're called in the middle of\n// a cache expiration.\nthis._rerunRequested=false;_context4.next=3;return this._timestampModel.expireEntries(Infinity);case 3:case\"end\":return _context4.stop();}}},_callee4,this);}));function _delete(){return _delete2.apply(this,arguments);}return _delete;}()}]);return CacheExpiration;}();export{CacheExpiration};","map":{"version":3,"sources":["/home/marketihor/scandipwa/node_modules/workbox-expiration/CacheExpiration.js"],"names":["assert","dontWaitFor","logger","WorkboxError","CacheTimestampsModel","CacheExpiration","cacheName","config","_isRunning","_rerunRequested","process","env","NODE_ENV","isType","moduleName","className","funcName","paramName","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_cacheName","_timestampModel","minTimestamp","Date","now","expireEntries","urlsExpired","self","caches","open","cache","url","delete","length","groupCollapsed","log","forEach","groupEnd","debug","setTimestamp","methodName","getTimestamp","timestamp","expireOlderThan","Infinity"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n                // TODO: Assert is positive\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n                // TODO: Assert is positive\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ?\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\n                    'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n            return (timestamp < expireOlderThan);\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n"]},"metadata":{},"sourceType":"module"}